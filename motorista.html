<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GARCIA TRANSPORTES - Motorista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: black; /* Fundo preto */
        }
        /* Removemos o gradiente principal do body pois agora ele é preto */
        /* .main-gradient { background: linear-gradient(135deg, #3b82f6, #a855f7); } */

        .button-gradient {
            background: linear-gradient(to right, #6d28d9, #4f46e5);
            border: 1px solid white; /* Contorno branco nos botões */
            color: white; /* Garante que o texto seja branco */
        }
        .button-gradient:hover {
            background: linear-gradient(to right, #4f46e5, #6d28d9);
        }

        /* NOVO ESTILO PARA O BOTÃO DA TELA INICIAL */
        .button-initial-screen {
            background-color: black;
            border: 2px solid white;
            color: white;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
            transition: box-shadow 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .button-initial-screen:hover {
            transform: scale(1.03);
            box-shadow: 0 0 16px rgba(255, 255, 255, 0.7);
        }

        .card-gradient {
             background: linear-gradient(135deg, #1f2937, #374151);
        }
        .screen {
            display: none; /* Todas as telas escondidas por padrão */
        }
        .screen.active {
            display: block; /* Exibe a tela ativa */
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #6d28d9;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ef4444;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #22c55e;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Centraliza verticalmente e horizontalmente o conteúdo APENAS da tela inicial */
        .center-content-initial {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 80vh; /* Garante que o conteúdo ocupe uma parte visível da tela */
        }

        /* Estilos para texto e inputs */
        body { color: white; }
        h1, h2, h3, p, button, label, span { color: white; }
        input::placeholder { color: #9ca3af; } /* Cinza claro para placeholder */
        input[type="date"] { color-scheme: dark; } /* Calendário escuro */
        .text-yellow-300 { color: #facc15 !important; } /* Mantém amarelo para botões de voltar */
        .text-gray-300 { color: #d1d5db !important; }
        .text-red-500 { color: #ef4444 !important; }
        .text-blue-300 { color: #93c5fd !important; }
        .text-orange-400 { color: #fb923c !important; }
        .text-blue-400 { color: #60a5fa !important; }

    </style>
</head>
<body class="text-white min-h-screen p-4 bg-black"> <div id="app-container" class="w-full mx-auto max-w-md"> <div id="initial-screen" class="screen active text-center center-content-initial"> <img src="images/motorista.png" alt="Motorista Icon" class="w-32 h-32 mx-auto mb-4 object-contain">
            <div class="flex justify-center items-center gap-4 mb-2">
                <div id="app-icon-container" class="h-12 w-12">
                    </div>
                <h1 class="text-4xl sm:text-5xl font-bold text-white">GARCIA TRANSPORTES</h1>
            </div>
            <div class="space-y-4 mt-8"> <button onclick="showScreen('driver-selection-screen')" class="w-full flex items-center justify-center gap-3 py-4 px-6 text-lg font-semibold rounded-lg button-initial-screen">
                    ÁREA DO MOTORISTA
                </button>
            </div>
        </div>

        <div id="driver-selection-screen" class="screen">
            <button onclick="showScreen('initial-screen')" class="mb-4 text-yellow-300">← Voltar</button>
            <h2 class="text-3xl font-bold mb-1 text-center text-white">Selecionar Motorista</h2>
            <p id="driver-selection-timestamp" class="text-center text-gray-300 text-sm mb-4"></p>
            <div id="driver-list-selection" class="space-y-3"></div>
        </div>

        <div id="driver-screen" class="screen">
            <button onclick="logoutDriver()" class="mb-4 text-yellow-300">← Sair</button>
            <h2 class="text-3xl font-bold mb-2 text-center text-white">Minhas Corridas</h2>
            <p id="driver-name-display" class="text-center text-yellow-300 mb-1"></p>
            <p id="driver-stats-display" class="text-center text-gray-300 font-semibold text-sm mb-6"></p> <div class="flex items-center justify-between mb-4 card-gradient p-3 rounded-lg">
                <span class="font-semibold text-lg text-white">Meu Status</span>
                <div class="flex items-center gap-3">
                    <span id="driver-status-label" class="font-bold text-white"></span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="driver-status-toggle" onchange="toggleDriverStatus()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div class="flex items-center justify-between mb-4 card-gradient p-3 rounded-lg">
                <span class="font-semibold text-lg text-white">MANTER TELA ATIVA</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="wake-lock-toggle" onchange="toggleWakeLock()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <button id="silence-btn" onclick="stopRinging()" class="hidden w-full mb-4 py-2 px-4 font-semibold rounded-lg bg-yellow-500 text-gray-900 border border-white">Silenciar Alerta</button>
            <div id="driver-jobs-list" class="space-y-4"></div>
             <div class="card-gradient p-4 rounded-lg mt-6">
                <div class="flex justify-between items-center">
                    <h3 class="font-semibold text-xl text-white">Exportar Histórico</h3>
                    <button onclick="showExportModal()" class="py-1 px-3 text-sm font-semibold rounded-lg bg-green-600 hover:bg-green-700 border border-white">Exportar</button>
                </div>
            </div>
        </div>

    </div>

    <div id="modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4">
        <div class="card-gradient p-6 rounded-lg shadow-xl text-center w-full max-w-sm">
            <p id="modal-message" class="mb-4 text-lg text-white"></p>
            <div id="modal-input-container" class="hidden mb-4 space-y-2">
                <input type="password" id="modal-input-driver-password" class="w-full p-2 rounded-lg bg-gray-800 border border-gray-600 focus:outline-none text-white" placeholder="Senha do Motorista">
            </div>
            <div id="modal-buttons" class="flex justify-center gap-4">
                 <button id="modal-cancel" onclick="closeModal()" class="py-2 px-6 font-semibold rounded-lg bg-gray-500 hover:bg-gray-600 border border-white">Cancelar</button>
                 <button id="modal-confirm" class="py-2 px-8 font-semibold rounded-lg button-gradient">OK</button>
            </div>
        </div>
    </div>

    <div id="export-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4">
        <div class="card-gradient p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="font-semibold text-xl text-white mb-4 text-center">Exportar Histórico para PDF</h3>
            <div class="space-y-4">
                <div>
                    <label for="start-date" class="block text-sm font-medium text-gray-300">Data Inicial</label>
                    <input type="date" id="start-date" class="w-full p-2 mt-1 rounded-lg bg-gray-800 border border-gray-600 text-white" style="color-scheme: dark;">
                </div>
                <div>
                    <label for="end-date" class="block text-sm font-medium text-gray-300">Data Final</label>
                    <input type="date" id="end-date" class="w-full p-2 mt-1 rounded-lg bg-gray-800 border border-gray-600 text-white" style="color-scheme: dark;">
                </div>
            </div>
            <div class="flex justify-center gap-4 mt-6">
                 <button onclick="closeExportModal()" class="py-2 px-6 font-semibold rounded-lg bg-gray-500 hover:bg-gray-600 border border-white">Cancelar</button>
                 <button onclick="exportRidesToPdf()" class="py-2 px-8 font-semibold rounded-lg button-gradient">Gerar PDF</button>
            </div>
        </div>
    </div>

    <audio id="ringtone" preload="auto" src="SOM/somchamada.mp3"></audio>
    <audio id="silent-audio" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA="></audio>

    <script>
        // --- CONFIGURAÇÃO INICIAL E DADOS MOCADOS ---
        let driverWatchId = null;
        let ringInterval = null;
        let tempDriverId = null; // Para login do motorista
        let audioUnlocked = false; // Flag para controlar o desbloqueio do áudio
        let wakeLock = null; // Variável para a funcionalidade de manter o ecrã ativo
        let mapOpenedForRideIds = []; // Armazena IDs de corridas agendadas cujo mapa foi aberto

        let state = {
            rides: [],
            drivers: [],
            currentDriverId: null,
            appIcon: 'images/destino.png', // Definido para usar o ícone "destino.png"
        };

        let rideProgress = {}; // To store current_stop_index locally

        function loadRideProgress() {
            const storedProgress = localStorage.getItem('rideProgress');
            if (storedProgress) {
                try {
                    rideProgress = JSON.parse(storedProgress);
                } catch(e) {
                    console.error("Erro ao carregar progresso da corrida:", e);
                    rideProgress = {}; // Reseta se houver erro
                }
            }
        }

        function saveRideProgress() {
            localStorage.setItem('rideProgress', JSON.stringify(rideProgress));
        }

        // --- CONFIGURAÇÃO DO SUPABASE ---
        const SUPABASE_URL = 'https://jowsbmuqbzxukbbxbeqv.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impvd3NibXVxYnp4dWtiYnhiZXF2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU0NzA5NjQsImV4cCI6MjA3MTA0Njk2NH0.UMW2aQmuq0RiEHgody5StKEQzDjrKZnfUprDgDaMd1w';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- LÓGICA DE NOTIFICAÇÕES E ÁUDIO ---
        const ringtone = document.getElementById('ringtone');
        const silentAudio = document.getElementById('silent-audio');

        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission !== 'denied') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Permissão para notificações concedida.');
                    }
                });
            }
        }

        function showNewRideNotification(ride) {
            startRinging();
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                console.warn('As notificações Pop-up estão bloqueadas.');
                return;
            }
            const notificationTitle = 'Nova Solicitação de Corrida!';
            // Usa a função parseDestinations para pegar o(s) destino(s)
            const destinations = parseDestinations(ride.destination);
            const bodyText = destinations.length > 0 ? `Destino(s): ${destinations.join(', ')}` : 'Destino não especificado';

            const notificationOptions = {
                body: bodyText,
                icon: 'images/destino.png', // Ícone da notificação
                tag: `ride-${ride.id}` // Tag para evitar notificações duplicadas
            };
            try {
                const notification = new Notification(notificationTitle, notificationOptions);
                notification.onclick = () => {
                    window.focus(); // Traz a janela do app para frente
                    notification.close();
                };
            } catch (e) {
                 console.error("Erro ao criar notificação:", e);
            }
        }

        function unlockAudio() {
            if (audioUnlocked) return;
            // Desbloqueia ambos os áudios de forma silenciosa
            const unlockPromise = Promise.all([ringtone, silentAudio].map(audio => {
                if (!audio) return Promise.resolve(false); // Verifica se o elemento existe
                return new Promise((resolve) => {
                    audio.muted = true;
                    audio.play().then(() => {
                        audio.pause();
                        audio.currentTime = 0;
                        audio.muted = false;
                        resolve(true);
                    }).catch(() => {
                        audio.muted = false; // Garante que não fique mudo se falhar
                        resolve(false);
                    });
                });
            }));

            unlockPromise.then(() => {
                audioUnlocked = true;
                console.log("Áudio desbloqueado pelo utilizador.");
                // Remove os listeners apenas se o desbloqueio for bem-sucedido
                document.body.removeEventListener('click', unlockAudio);
                document.body.removeEventListener('touchstart', unlockAudio);
            });
        }

        // Adiciona listeners para interação do usuário
        document.body.addEventListener('click', unlockAudio, { once: true }); // Tenta desbloquear na primeira interação
        document.body.addEventListener('touchstart', unlockAudio, { once: true });

        function playRingSound() {
            if (!audioUnlocked || !ringtone) return;
            ringtone.currentTime = 0;
            ringtone.play().catch(e => console.error("Erro ao tocar som:", e));
        }

        function startRinging() {
            stopRinging();
            playRingSound();
            ringInterval = setInterval(playRingSound, 6000); // Toca a cada 6 segundos
            document.getElementById('silence-btn').classList.remove('hidden');
        }

        function stopRinging() {
            if (ringInterval) {
                clearInterval(ringInterval);
                ringInterval = null;
            }
             if (ringtone) {
                ringtone.pause();
                ringtone.currentTime = 0;
            }
            document.getElementById('silence-btn').classList.add('hidden');
        }

        // --- LÓGICA PARA MANTER O ECRÃ E APP ATIVOS ---
        const requestWakeLock = async () => {
            if (wakeLock) return; // Já está ativo
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock (manter ecrã ativo) ativado.');
                    // Reativa se for liberado pelo sistema (ex: aba em background)
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock foi liberado.');
                        wakeLock = null;
                        // Tenta reativar se o toggle ainda estiver marcado
                        if (document.getElementById('wake-lock-toggle').checked) {
                            requestWakeLock();
                        }
                    });
                } else {
                     console.warn("Wake Lock API não suportada neste navegador.");
                     document.getElementById('wake-lock-toggle').disabled = true; // Desabilita o toggle
                }
            } catch (err) {
                console.error(`Erro ao ativar Wake Lock: ${err.name}, ${err.message}`);
                // Desmarca o toggle se falhar
                document.getElementById('wake-lock-toggle').checked = false;
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLock) {
                await wakeLock.release();
                // O listener 'release' vai setar wakeLock = null
                console.log('Wake Lock (manter ecrã ativo) solicitado para liberar.');
            }
        };

        // Função chamada pelo toggle
        async function toggleWakeLock() {
            const isChecked = document.getElementById('wake-lock-toggle').checked;
            if (isChecked) {
                await requestWakeLock();
                // Tenta manter a app "viva" com áudio silencioso
                if (audioUnlocked && silentAudio) {
                   silentAudio.play().catch(e => console.error("Erro ao tocar áudio silencioso:", e));
                }
            } else {
                await releaseWakeLock();
                 if (silentAudio) {
                    silentAudio.pause();
                }
            }
        }

        // Adiciona listener para reativar o Wake Lock quando a aba volta a ficar visível
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // --- LÓGICA DE MODAL --- (sem alterações)
        function showModal(message, onConfirm, showCancel = false, content = {}) {
            document.getElementById('modal-message').textContent = message;
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');
            const inputContainer = document.getElementById('modal-input-container');
            Array.from(inputContainer.children).forEach(child => child.style.display = 'none');
            if (content.type === 'driver-password') {
                inputContainer.classList.remove('hidden');
                document.getElementById('modal-input-driver-password').style.display = 'block';
                document.getElementById('modal-input-driver-password').value = '';
            } else {
                 inputContainer.classList.add('hidden');
            }
            confirmBtn.onclick = onConfirm;
            cancelBtn.style.display = showCancel ? 'inline-block' : 'none';
            confirmBtn.textContent = showCancel ? 'Confirmar' : 'OK';
            if (!showCancel) confirmBtn.onclick = closeModal;
            const modal = document.getElementById('modal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            document.getElementById('modal-input-driver-password').value = '';
        }

        function showExportModal() {
            document.getElementById('export-modal').classList.remove('hidden');
            document.getElementById('export-modal').classList.add('flex');
        }

        function closeExportModal() {
            document.getElementById('export-modal').classList.add('hidden');
            document.getElementById('export-modal').classList.remove('flex');
        }

        // --- NAVEGAÇÃO ENTRE TELAS --- (sem alterações lógicas)
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            stopRinging();

            const appContainer = document.getElementById('app-container');
            const initialScreen = document.getElementById('initial-screen');
            // Controla a classe de centralização baseada na tela
            if (screenId === 'initial-screen' && initialScreen) {
                 initialScreen.classList.add('center-content-initial');
            } else if (initialScreen){
                 initialScreen.classList.remove('center-content-initial');
            }

            if (screenId === 'driver-selection-screen') populateDriverSelection();
            if (screenId === 'driver-screen') {
                loadDriverJobs();
                updateDriverStatusButton();
            }
        }

        // --- LÓGICA DO MOTORISTA ---

        function populateDriverSelection() {
            const list = document.getElementById('driver-list-selection');
            const timestampEl = document.getElementById('driver-selection-timestamp');
            list.innerHTML = '';
            const timestamp = new Date().toLocaleString('pt-BR');
            timestampEl.textContent = `Status atualizado em ${timestamp}`;
            state.drivers.sort((a, b) => a.name.localeCompare(b.name));
            state.drivers.forEach(driver => {
                const isDriverBusy = state.rides.some(ride => ride.driverId === driver.id && ride.status !== 'completed' && ride.status !== 'canceled' && ride.status !== 'canceled_by_driver');
                const button = document.createElement('button');
                button.className = 'w-full py-3 px-6 text-lg font-semibold rounded-lg card-gradient shadow-lg transform hover:scale-105 transition-transform flex justify-between items-center border border-white';
                button.onclick = () => selectDriver(driver.id);
                button.innerHTML = `
                    <span class="text-white">${driver.name}</span>
                    <span class="text-sm font-bold py-1 px-3 rounded-full ${driver.status === 'active' && !isDriverBusy ? 'bg-green-500 text-white' : 'bg-red-600 text-white'}">
                        ${driver.status === 'active' && !isDriverBusy ? 'Livre' : 'Ocupado'}
                    </span>
                `;
                list.appendChild(button);
            });
        }

        function selectDriver(driverId) {
            tempDriverId = driverId;
            const driver = state.drivers.find(d => d.id === driverId);
            if (!driver) {
                showModal('Motorista não encontrado.');
                return;
            }
            const onConfirm = () => {
                const passwordInput = document.getElementById('modal-input-driver-password');
                if (passwordInput.value.trim() === driver.password.trim()) {
                    state.currentDriverId = driverId;
                    localStorage.setItem('loggedInDriverId', driverId);
                    requestNotificationPermission(); // Pede permissão ao logar
                    document.getElementById('driver-name-display').textContent = `Bem-vindo, ${driver.name}`;
                    updateDriverStatusButton();
                    showScreen('driver-screen');
                    closeModal();
                } else {
                    document.getElementById('modal-message').textContent = "Senha Incorreta!";
                    passwordInput.value = '';
                }
            };
            showModal(`Login para ${driver.name}`, onConfirm, true, { type: 'driver-password' });
        }

        async function logoutDriver() {
            state.currentDriverId = null;
            localStorage.removeItem('loggedInDriverId');
            if (driverWatchId) {
                navigator.geolocation.clearWatch(driverWatchId);
                driverWatchId = null;
            }
            // Libera o Wake Lock e para o áudio silencioso ao deslogar
            await releaseWakeLock();
             if (silentAudio) {
                silentAudio.pause();
            }
            document.getElementById('wake-lock-toggle').checked = false; // Desmarca o toggle
            // Garante que a classe de centralização seja removida
             const initialScreen = document.getElementById('initial-screen');
             if (initialScreen) initialScreen.classList.remove('center-content-initial');
            showScreen('initial-screen');
        }


        async function updateDriverStatusButton() {
            if (!state.currentDriverId) return;
            const driver = state.drivers.find(d => d.id === state.currentDriverId);
            if (driver) {
                const statusLabel = document.getElementById('driver-status-label');
                const statusToggle = document.getElementById('driver-status-toggle');
                if (driver.status === 'active') {
                    statusLabel.textContent = 'ATIVO';
                    statusLabel.className = 'font-bold text-green-400'; // Verde para ativo
                    statusToggle.checked = true;
                } else {
                    statusLabel.textContent = 'INATIVO';
                    statusLabel.className = 'font-bold text-red-400'; // Vermelho para inativo
                    statusToggle.checked = false;
                }
            }
        }

        async function toggleDriverStatus() {
            if (!state.currentDriverId) return;
            const statusToggle = document.getElementById('driver-status-toggle');
            const newStatus = statusToggle.checked ? 'active' : 'inactive';
            const { error } = await supabaseClient
                .from('drivers')
                .update({ status: newStatus })
                .eq('id', state.currentDriverId);
            if (error) {
                console.error("Erro ao atualizar status:", error);
                showModal("Não foi possível atualizar seu status.");
                statusToggle.checked = !statusToggle.checked; // Reverte o toggle visualmente
            } else {
                // Atualiza o estado localmente para refletir a mudança imediatamente
                const driverIndex = state.drivers.findIndex(d => d.id === state.currentDriverId);
                if (driverIndex !== -1) {
                    state.drivers[driverIndex].status = newStatus;
                }
                updateDriverStatusButton(); // Atualiza a label e a cor
            }
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - parseDestinations
        // ========================================================================
        // Função robusta para interpretar o campo 'destination'
        function parseDestinations(destinationString) {
            if (!destinationString || typeof destinationString !== 'string') {
                console.warn("parseDestinations: Input inválido ou vazio:", destinationString);
                return [];
            }
            const str = destinationString.trim();

            // 1. Tenta interpretar como um array JSON formal (ex: ["addr1", "addr2"] ou [{"name": "n", "address": "a"}, ...])
            if (str.startsWith('[') && str.endsWith(']')) {
                try {
                    const parsed = JSON.parse(str);
                    if (Array.isArray(parsed)) {
                        // Se for array de objetos {name, address}, extrai 'address'
                        if (parsed.length > 0 && typeof parsed[0] === 'object' && parsed[0] !== null && 'address' in parsed[0]) {
                           return parsed.map(d => String(d.address || '').trim()).filter(Boolean);
                        }
                        // Senão, trata como array de strings
                        return parsed.map(d => String(d || '').trim()).filter(Boolean);
                    }
                } catch (e) {
                    console.warn('parseDestinations: Não foi possível interpretar como JSON, tentando extração manual.', str, e);
                    // 2. Método Alternativo: Se JSON.parse falhar, extrai manualmente.
                    const content = str.substring(1, str.length - 1);
                    const parts = content.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
                    if (parts.length > 0) {
                        return parts.map(part => part.replace(/^"|"$/g, '').trim()).filter(Boolean);
                    }
                }
            }

            // 3. Fallback: Trata como um único destino (remove aspas se houver)
            return [str.replace(/^"|"$/g, '').trim()].filter(Boolean);
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - openMapToDestination (Usa Waze)
        // ========================================================================
        function openMapToDestination(rideId) {
            const ride = state.rides.find(r => r.id === rideId);
            if (!ride) {
                showModal("Não foi possível encontrar os dados da corrida.");
                return;
            }

            const destinations = parseDestinations(ride.destination); // Usa a função parse
            console.log("Destinos parseados:", destinations);

            if (destinations.length > 0) {
                // Pega o índice da parada atual (você já tem essa lógica)
                const currentStopIndex = rideProgress[ride.id] || 0;
                let targetAddress = '';

                // Determina qual endereço usar
                if (currentStopIndex < destinations.length) {
                    // Pega o próximo destino/parada da lista parseada
                    targetAddress = destinations[currentStopIndex];
                } else {
                    // Se o índice for inválido, pega o último destino como fallback
                    targetAddress = destinations[destinations.length - 1];
                    console.warn(`Índice de parada (${currentStopIndex}) inválido para ${destinations.length} destinos. Usando o último.`);
                }

                console.log(`Abrindo Waze para: ${targetAddress} (Índice: ${currentStopIndex})`);
                // Link do Waze para busca por endereço
                window.open(`waze://?q=${encodeURIComponent(targetAddress)}&navigate=yes`, '_blank');

            } else {
                showModal("Nenhum destino definido para esta corrida.");
            }
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - openMapToPickup (Usa Waze)
        // ========================================================================
        function openMapToPickup(rideId) {
            // Marca que o mapa foi aberto para este agendamento, se aplicável
            const ride = state.rides.find(r => r.id === rideId);
            if (ride && ride.request_type === 'scheduled' && !mapOpenedForRideIds.includes(rideId)) {
                mapOpenedForRideIds.push(rideId);
            }

            if (ride && ride.userLocation && ride.userLocation.lat && ride.userLocation.lon) {
                const { lat, lon } = ride.userLocation;
                console.log(`Abrindo Waze para embarque (coords): ${lat}, ${lon}`);
                // Link do Waze para coordenadas
                window.open(`waze://?ll=${lat},${lon}&navigate=yes`, '_blank');
            } else if (ride && ride.origin_address) {
                // Fallback para endereço de origem se as coordenadas não estiverem salvas
                console.log(`Abrindo Waze para embarque (endereço): ${ride.origin_address}`);
                window.open(`waze://?q=${encodeURIComponent(ride.origin_address)}&navigate=yes`, '_blank');
            } else {
                showModal("Não foi possível obter a localização do usuário ou endereço de origem para navegação.");
            }
            // Atualiza a interface após abrir o mapa (importante para agendamentos)
            loadDriverJobs();
        }


        function loadDriverJobs() {
            if (!state.currentDriverId) return;
            const list = document.getElementById('driver-jobs-list');
            list.innerHTML = ''; // Limpa a lista

            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            // Filtra corridas relevantes para o motorista
            const myJobs = state.rides.filter(r => {
                // Ignora se não for do motorista ou se já estiver completa
                if (r.driverId !== state.currentDriverId || r.status === 'completed') {
                    return false;
                }
                // Ignora corridas canceladas PELO MOTORISTA (mas mostra as canceladas pelo usuário/admin)
                if (r.status === 'canceled_by_driver') {
                    return false;
                }

                const isScheduled = r.request_type === 'scheduled';
                const rideDateSource = isScheduled && r.scheduled_datetime ? r.scheduled_datetime : r.requestTime;

                // Tenta criar a data da corrida
                let rideDate;
                try {
                     rideDate = new Date(rideDateSource);
                     if (isNaN(rideDate.getTime())) throw new Error("Data inválida"); // Checa se a data é válida
                } catch(e) {
                     console.error(`Data inválida para corrida ID ${r.id}: ${rideDateSource}`, e);
                     return false; // Ignora corridas com data inválida
                }

                const rideDayStart = new Date(rideDate.getFullYear(), rideDate.getMonth(), rideDate.getDate());

                // Lógica de exibição:
                // 1. Corridas imediatas DO DIA ATUAL
                // 2. Corridas agendadas PARA HOJE OU FUTURO
                // 3. Corridas JÁ ACEITAS (mesmo que de dias anteriores, caso não tenham sido concluídas)
                if (r.status === 'accepted' || r.status === 'arrived_pickup' || r.status === 'in_progress') {
                    return true;
                }
                if (!isScheduled && rideDayStart.getTime() === todayStart.getTime()) {
                    return true;
                }
                if (isScheduled && rideDayStart >= todayStart) {
                    return true;
                }

                return false; // Ignora outras corridas (ex: imediatas de ontem não aceitas)
            });

            // Atualiza o contador de solicitações
            const statsDisplay = document.getElementById('driver-stats-display');
            // Conta apenas as que requerem ação (não canceladas)
            const actionableJobCount = myJobs.filter(j => j.status !== 'canceled').length;
            const timestamp = new Date().toLocaleString('pt-BR');
            statsDisplay.textContent = `${actionableJobCount} solicitações ativas em ${timestamp}`;

            // Mensagem se não houver corridas
            if (myJobs.length === 0) {
                list.innerHTML = '<p class="text-center text-gray-400">Nenhuma corrida para você no momento.</p>';
                // Para o rastreamento se não houver mais corridas ativas
                if (driverWatchId) {
                    navigator.geolocation.clearWatch(driverWatchId);
                    driverWatchId = null;
                }
                return;
            }

            // Ordena: Aceitas/Em Andamento primeiro, depois por data (mais recente primeiro)
            myJobs.sort((a, b) => {
                 const statusOrder = { 'in_progress': 1, 'arrived_pickup': 2, 'accepted': 3, 'assigned': 4, 'scheduled': 5 };
                 const orderA = statusOrder[a.status] || 99;
                 const orderB = statusOrder[b.status] || 99;
                 if (orderA !== orderB) return orderA - orderB;

                 const dateA = new Date(a.scheduled_datetime || a.requestTime);
                 const dateB = new Date(b.scheduled_datetime || b.requestTime);
                 return dateA - dateB; // Mais próximos primeiro para agendados/solicitados
            });

            let hasAssignedJob = false; // Flag para tocar o alarme

            // Renderiza os cards
            myJobs.forEach(ride => {
                const card = document.createElement('div');
                card.className = 'card-gradient p-4 rounded-lg shadow-md border border-white'; // Borda branca adicionada

                const isScheduled = ride.request_type === 'scheduled';
                const typeText = isScheduled ? 'Agendada' : 'Imediata';
                const typeColor = isScheduled ? 'text-orange-400' : 'text-blue-400';

                // Data a ser exibida (agendada ou da solicitação)
                const displayDateSource = isScheduled && ride.scheduled_datetime ? ride.scheduled_datetime : ride.requestTime;
                let displayDateTime = 'Data inválida';
                 try {
                     const dateObj = new Date(displayDateSource);
                     if (!isNaN(dateObj.getTime())) {
                         displayDateTime = dateObj.toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
                     }
                 } catch(e) { /* Mantém 'Data inválida' */ }

                const dateLabel = isScheduled ? 'Agendado para:' : 'Solicitado em:';

                // Cor do status
                let statusColor = 'text-yellow-300';
                if (ride.status === 'canceled') { statusColor = 'text-red-500'; }
                else if (ride.status === 'completed') { statusColor = 'text-green-400'; } // Embora filtradas, por segurança
                else if (ride.status === 'in_progress' || ride.status === 'arrived_pickup') { statusColor = 'text-purple-400'; }
                else if (ride.status === 'accepted') { statusColor = 'text-blue-400'; }


                // --- Origem ---
                let originHtml = ride.origin_address ? `
                    <div class="mb-3">
                        <p class="text-xs text-gray-300">Origem:</p>
                        <p class="font-normal text-gray-300 break-words">${ride.origin_address}</p>
                    </div>` : '';

                // --- Destinos ---
                let destinationsHtml = '';
                const destinations = parseDestinations(ride.destination); // Usa a função parse
                const currentStopIndex = rideProgress[ride.id] || 0; // Pega o progresso local

                if (destinations.length > 0) {
                     destinationsHtml = '<div class="mb-3 space-y-2">';
                     destinations.forEach((dest, index) => {
                         const isFinal = index === destinations.length - 1;
                         const isNextStop = index === currentStopIndex;
                         const isPastStop = index < currentStopIndex;

                         let label = '';
                         let textColor = 'text-gray-300'; // Cor padrão
                         let fontWeight = 'font-normal';
                         let indicator = ''; // Indicador visual (opcional)

                         if (isFinal) {
                             label = 'Destino Final:';
                             fontWeight = 'font-semibold';
                             textColor = 'text-white'; // Destaca o final
                         } else {
                             label = `Parada ${index + 1}:`;
                         }

                         if (ride.status === 'in_progress') {
                            if (isNextStop) {
                                textColor = 'text-yellow-300'; // Destaca a próxima parada
                                fontWeight = 'font-bold';
                                indicator = '▶️ '; // Indicador de "próximo"
                            } else if (isPastStop) {
                                textColor = 'text-gray-500 line-through'; // Tacha paradas concluídas
                                indicator = '✅ ';
                            }
                         }

                         destinationsHtml += `
                            <div>
                                <p class="text-xs ${textColor}">${indicator}${label}</p>
                                <p class="${fontWeight} ${textColor} break-words">${dest}</p>
                            </div>
                         `;
                     });
                     destinationsHtml += '</div>';
                } else {
                     destinationsHtml = `
                        <div class="mb-3">
                             <p class="text-xs text-gray-300">Destino:</p>
                             <p class="font-normal text-gray-300">N/A</p>
                        </div>`;
                }


                // --- Montagem do Card ---
                let content = `
                    <div class="mb-2">
                        <p class="text-xs text-gray-300">${dateLabel}</p>
                        <p class="font-semibold text-white">${displayDateTime}</p>
                    </div>
                    ${originHtml}
                    ${destinationsHtml}
                    ${ride.observation ? `
                    <div class="mb-3">
                        <p class="text-xs text-gray-300">Observação:</p>
                        <p class="font-normal text-yellow-300 break-words">${ride.observation}</p>
                    </div>` : ''}
                    <p class="text-sm text-gray-300 mb-3">Solicitado por: ${ride.userName} ${ride.userCompany ? `(${ride.userCompany})` : ''}</p>
                    <div class="mt-3 pt-3 border-t border-gray-600 flex justify-around items-center text-center">
                        <div>
                            <p class="text-xs text-gray-300 mb-1">TIPO</p>
                            <p class="text-sm font-semibold ${typeColor}">${typeText}</p>
                        </div>
                        <div>
                            <p class="text-xs text-gray-300 mb-1">STATUS</p>
                            <p class="text-sm font-semibold ${statusColor}">${translateStatus(ride.status)}</p>
                        </div>
                    </div>`;

                // --- Distância (se aplicável) ---
                let rideSpecificContent = '';
                if (ride.status === 'accepted' && ride.driverCurrentLocation && ride.userLocation) {
                    try {
                        const distance = getDistanceFromLatLonInKm(
                            ride.driverCurrentLocation.lat, ride.driverCurrentLocation.lon,
                            ride.userLocation.lat, ride.userLocation.lon
                        );
                        rideSpecificContent = `<p class="text-sm text-blue-300 mt-2 text-center">Distância até o usuário: ${distance.toFixed(2)} km</p>`;
                    } catch (e) {
                         console.error("Erro ao calcular distância:", e);
                         rideSpecificContent = `<p class="text-sm text-gray-400 mt-2 text-center">Erro ao calcular distância</p>`;
                    }
                } else if (ride.status === 'accepted') {
                     rideSpecificContent = `<p class="text-sm text-gray-400 mt-2 text-center">Calculando distância...</p>`;
                }

                // --- Botões de Ação ---
                let buttonsContent = '';
                // Não mostra botões se cancelada pelo usuário/admin
                if (ride.status !== 'canceled') {
                    buttonsContent = '<div class="mt-4 space-y-2">';
                    if (ride.status === 'assigned') {
                        hasAssignedJob = true; // Toca o alarme
                        if (isScheduled) {
                            buttonsContent += `<button onclick="acceptScheduledRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">ACEITAR AGENDAMENTO</button>`;
                        } else {
                            buttonsContent += `<button onclick="acceptRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">ACEITAR CORRIDA</button>`;
                        }
                        // Botão de cancelar enquanto 'assigned'
                        buttonsContent += `<button onclick="promptCancelRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-red-600 hover:bg-red-700 border border-white">CANCELAR</button>`;

                    } else if (ride.status === 'accepted') {
                        // Lógica para corridas agendadas: mostrar "Cheguei" só depois de abrir o mapa
                        if (isScheduled) {
                            if (mapOpenedForRideIds.includes(ride.id)) {
                                buttonsContent += `<button onclick="arriveAtPickup(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">CHEGUEI NO LOCAL DE EMBARQUE</button>`;
                                // Botão mapa embarque sempre visível após aceitar agendamento
                                buttonsContent += `<button onclick="openMapToPickup(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700 border border-white">MAPA (EMBARQUE)</button>`;
                            } else {
                                // Antes de abrir o mapa pela 1ª vez, só mostra o botão do mapa
                                buttonsContent += `<button onclick="openMapToPickup(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700 border border-white">MAPA (EMBARQUE)</button>`;
                            }
                        } else { // Corridas imediatas
                            buttonsContent += `<button onclick="arriveAtPickup(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">CHEGUEI NO LOCAL DE EMBARQUE</button>`;
                            buttonsContent += `<button onclick="openMapToPickup(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700 border border-white">MAPA (EMBARQUE)</button>`;
                        }
                        // Botão de cancelar enquanto 'accepted'
                        buttonsContent += `<button onclick="promptCancelRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-red-600 hover:bg-red-700 border border-white">CANCELAR</button>`;

                    } else if (ride.status === 'arrived_pickup') {
                        buttonsContent += `<button onclick="startTrip(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">INICIAR VIAGEM</button>`;
                        buttonsContent += `<button onclick="openMapToDestination(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700 border border-white">VER ROTA NO MAPA</button>`;
                        // Botão de cancelar enquanto 'arrived_pickup'
                        buttonsContent += `<button onclick="promptCancelRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-red-600 hover:bg-red-700 border border-white">CANCELAR</button>`;

                    } else if (ride.status === 'in_progress') {
                        // Lógica de paradas
                        if (destinations.length > 1 && currentStopIndex < destinations.length - 1) {
                            // Botão para avançar para a próxima parada
                            buttonsContent += `<button onclick="advanceToNextStop(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg button-gradient">CONFIRMAR CHEGADA NA PARADA ${currentStopIndex + 1}</button>`;
                        } else {
                            // Botão para finalizar a corrida (última parada ou destino único)
                            buttonsContent += `<button onclick="completeRide(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-green-600 hover:bg-green-700 border border-white">FINALIZAR CORRIDA</button>`;
                        }
                        buttonsContent += `<button onclick="openMapToDestination(${ride.id})" class="w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700 border border-white">VER ROTA NO MAPA</button>`;
                        // NÃO há botão de cancelar em progresso
                    }
                    buttonsContent += '</div>'; // Fecha a div dos botões
                }


                card.innerHTML = content + rideSpecificContent + buttonsContent;
                list.appendChild(card);
            });

            // Toca o alarme se houver alguma corrida designada
            if (hasAssignedJob) {
                startRinging();
            } else {
                stopRinging(); // Garante que pare se não houver mais corridas designadas
            }
        }


        async function acceptRide(rideId) {
            stopRinging();
            if (!navigator.geolocation) return showModal("Geolocalização não é suportada.");

            navigator.geolocation.getCurrentPosition(async (position) => {
                const driverLocation = { lat: position.coords.latitude, lon: position.coords.longitude };
                const { error } = await supabaseClient
                    .from('rides')
                    .update({
                        status: 'accepted',
                        acceptTime: new Date().toISOString(),
                        driverCurrentLocation: driverLocation
                    })
                    .eq('id', rideId);

                if (error) {
                    console.error("Erro ao aceitar corrida:", error);
                    showModal("Não foi possível aceitar a corrida.");
                    return;
                }

                // Inicia o rastreamento APÓS aceitar com sucesso
                startDriverTracking(rideId);
                // Abre o mapa para o local de embarque
                openMapToPickup(rideId);

            }, (geoError) => {
                console.error("Erro ao obter localização:", geoError);
                showModal('Não foi possível obter sua localização para aceitar a corrida.');
            }, { enableHighAccuracy: true });
        }


        async function acceptScheduledRide(rideId) {
            stopRinging();
            const { error } = await supabaseClient.from('rides').update({
                status: 'accepted', // Muda status para aceito
                acceptTime: new Date().toISOString()
            }).eq('id', rideId);

            if (error) {
                console.error("Erro ao aceitar agendamento:", error);
                showModal("Não foi possível aceitar o agendamento.");
            } else {
                 // Não abre o mapa aqui, apenas atualiza o status
                 // O motorista abrirá o mapa manualmente mais tarde
                 loadDriverJobs(); // Atualiza a lista para mostrar os novos botões
            }
        }

        async function arriveAtPickup(rideId) {
            const { error } = await supabaseClient
                .from('rides')
                .update({ status: 'arrived_pickup' })
                .eq('id', rideId);

            if (error) {
                console.error("Erro ao marcar 'chegou no local':", error);
                showModal("Não foi possível marcar como 'chegou no local'.");
            }
            // Não precisa mais abrir o mapa aqui, já foi aberto antes ou será aberto para o destino
        }


        async function startTrip(rideId) {
            const { error } = await supabaseClient
                .from('rides')
                .update({ status: 'in_progress' })
                .eq('id', rideId);

            if (error) {
                console.error("Erro ao iniciar viagem:", error);
                showModal("Não foi possível iniciar a viagem.");
                return; // Sai se houver erro
            }

            // Define o progresso inicial para a primeira parada/destino
            rideProgress[rideId] = 0;
            saveRideProgress();

            // Para o rastreamento de localização (não precisamos mais rastrear o motorista indo para o cliente)
            if (driverWatchId) {
                navigator.geolocation.clearWatch(driverWatchId);
                driverWatchId = null;
                console.log("Rastreamento de localização parado.");
            }

            // Abre o mapa para o próximo destino (que agora é o índice 0)
            openMapToDestination(rideId);
             loadDriverJobs(); // Atualiza a interface para mostrar o novo status e botões
        }

        async function advanceToNextStop(rideId) {
            const ride = state.rides.find(r => r.id === rideId);
            if (!ride) return showModal("Corrida não encontrada.");

            const currentStopIndex = rideProgress[ride.id] || 0;
            const destinations = parseDestinations(ride.destination);

            // Verifica se realmente há uma próxima parada
            if (currentStopIndex < destinations.length - 1) {
                rideProgress[ride.id] = currentStopIndex + 1; // Avança o índice
                saveRideProgress(); // Salva o novo índice

                // Abre o mapa para a *próxima* parada/destino
                openMapToDestination(rideId);
                 loadDriverJobs(); // Atualiza a interface
            } else {
                 console.warn("Tentativa de avançar além da última parada.");
                 // Talvez mostrar o botão de finalizar? Recarrega a UI.
                 loadDriverJobs();
            }
        }

        async function completeRide(rideId) {
            const { error } = await supabaseClient
                .from('rides')
                .update({ status: 'completed' })
                .eq('id', rideId);

            if (error) {
                 console.error("Erro ao finalizar corrida:", error);
                 showModal("Não foi possível finalizar a corrida.");
                 return; // Sai se houver erro
            }

            // Limpa o progresso da corrida finalizada
            if (rideProgress[rideId] !== undefined) {
                delete rideProgress[rideId];
                saveRideProgress();
            }

            // Garante que o rastreamento esteja parado
            if (driverWatchId) {
                navigator.geolocation.clearWatch(driverWatchId);
                driverWatchId = null;
                console.log("Rastreamento parado ao completar corrida.");
            }

            // Atualiza os dados e volta para a tela de seleção
            await fetchAllData(); // Pega o estado mais recente
            // Não volta mais para seleção, apenas atualiza a lista
            loadDriverJobs();
             showModal("Corrida finalizada com sucesso!"); // Feedback para o motorista
             // Poderia voltar para a tela de seleção se desejado:
             // showScreen('driver-selection-screen');
        }


        function promptCancelRide(rideId) {
            const onConfirm = () => cancelRideByDriver(rideId);
            showModal("Tem certeza que deseja cancelar esta corrida?", onConfirm, true);
            document.getElementById('modal-confirm').textContent = 'SIM, CANCELAR'; // Texto mais claro
            document.getElementById('modal-cancel').textContent = 'NÃO';
        }

        async function cancelRideByDriver(rideId) {
            closeModal(); // Fecha o modal de confirmação
            const { error } = await supabaseClient
                .from('rides')
                .update({ status: 'canceled_by_driver' }) // Status específico
                .eq('id', rideId);

            if (error) {
                console.error("Erro ao cancelar corrida:", error);
                showModal("Não foi possível cancelar a corrida.");
            } else {
                 // Para o rastreamento se estava ativo
                 const ride = state.rides.find(r => r.id === rideId);
                 if (driverWatchId && ride && ride.status !== 'in_progress') { // Só para se não estiver EM VIAGEM
                     navigator.geolocation.clearWatch(driverWatchId);
                     driverWatchId = null;
                     console.log("Rastreamento parado devido ao cancelamento.");
                 }
                  // Limpa o progresso local se houver
                  if (rideProgress[rideId] !== undefined) {
                      delete rideProgress[rideId];
                      saveRideProgress();
                  }
                 // Não precisa buscar todos os dados, apenas remove o card visualmente ou atualiza a lista
                 // A atualização via real-time deve cuidar disso, mas podemos forçar:
                 loadDriverJobs();
                 showModal("Corrida cancelada."); // Feedback
            }
        }


        function startDriverTracking(rideId) {
            if (!navigator.geolocation) {
                console.warn("Geolocalização não suportada, não é possível rastrear.");
                return;
            }

            // Limpa qualquer watcher anterior
            if (driverWatchId) {
                navigator.geolocation.clearWatch(driverWatchId);
                console.log("Watcher anterior limpo.");
            }

            console.log(`Iniciando rastreamento para corrida ${rideId}...`);
            driverWatchId = navigator.geolocation.watchPosition(
                async (position) => {
                    const driverLocation = { lat: position.coords.latitude, lon: position.coords.longitude };
                    //console.log(`Posição atualizada: ${driverLocation.lat}, ${driverLocation.lon}`);

                    // Verifica se a corrida ainda existe e está em um status que precisa de rastreamento
                    // (Aceita ou Chegou no embarque)
                    const currentRide = state.rides.find(r => r.id === rideId && ['accepted', 'arrived_pickup'].includes(r.status));

                    if (currentRide) {
                        // Atualiza a localização no Supabase
                        const { error } = await supabaseClient
                            .from('rides')
                            .update({ driverCurrentLocation: driverLocation })
                            .eq('id', rideId);
                        if (error) {
                            console.error("Erro ao atualizar localização no Supabase:", error);
                        }
                        // Atualiza o estado local também para cálculo de distância na UI
                        currentRide.driverCurrentLocation = driverLocation;
                        // Opcional: Recarregar a UI para mostrar a distância atualizada
                        if (document.querySelector('.screen.active')?.id === 'driver-screen') {
                             loadDriverJobs(); // Atualiza a UI se a tela estiver visível
                        }

                    } else {
                        // Se a corrida não está mais nesses status (iniciou, completou, cancelou), para o watcher
                        console.log(`Corrida ${rideId} não está mais em status 'accepted' ou 'arrived_pickup'. Parando rastreamento.`);
                        navigator.geolocation.clearWatch(driverWatchId);
                        driverWatchId = null;
                    }
                },
                (error) => {
                    console.error("Erro no rastreamento de localização:", error.message, `(Code: ${error.code})`);
                    // Não para o watcher em caso de erro temporário
                },
                {
                    enableHighAccuracy: true, // Tenta usar GPS
                    timeout: 10000,          // Timeout de 10s para obter a posição
                    maximumAge: 0            // Não usar posições em cache
                }
            );
        }


        // --- Funções getDistanceFromLatLonInKm, deg2rad --- (sem alterações)
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) return NaN; // Verifica dados nulos
            const R = 6371; // Raio da Terra em km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const d = R * c; // Distância em km
            return d;
        }
        function deg2rad(deg) { return deg * (Math.PI / 180); }

        // --- fetchAllData --- (sem alterações)
        async function fetchAllData() {
            // Usa Promise.all para buscar em paralelo
            const [driversRes, ridesRes] = await Promise.all([
                supabaseClient.from('drivers').select('*'),
                supabaseClient.from('rides').select('id, origin_address, destination, status, driverId, userName, userCompany, requestTime, userLocation, driverCurrentLocation, request_type, scheduled_datetime, observation')
            ]);

            if (driversRes.error) console.error('Erro a buscar motoristas:', driversRes.error);
            else state.drivers = driversRes.data || [];

            if (ridesRes.error) console.error('Erro a buscar corridas:', ridesRes.error);
            else state.rides = ridesRes.data || [];

             // Atualiza o botão de status se o motorista estiver logado
             if (state.currentDriverId) {
                updateDriverStatusButton();
            }
        }


        // --- setupRealtimeSubscriptions --- (sem alterações lógicas, apenas logs)
        function setupRealtimeSubscriptions() {
            const ridesChannel = supabaseClient.channel('public:rides');
            ridesChannel.on('postgres_changes', { event: '*', schema: 'public', table: 'rides' },
                async (payload) => {
                    console.log('Real-time event received (rides):', payload.eventType, payload.new?.status || payload.old?.status);

                    const newRecord = payload.new;
                    const oldRecord = payload.old;
                    const relevantDriverId = newRecord?.driverId || oldRecord?.driverId;

                    // Atualiza todos os dados para garantir consistência
                    await fetchAllData();

                    // Lógica de notificação/alarme para o motorista LOGADO
                    if (state.currentDriverId && relevantDriverId === state.currentDriverId) {
                         // Toca alarme se uma corrida for ASSIGNED a este motorista
                        if (payload.eventType === 'UPDATE' && newRecord.status === 'assigned' && oldRecord.status !== 'assigned') {
                            showNewRideNotification(newRecord); // Mostra popup e toca alarme
                        }
                         // Para o alarme se a corrida designada for aceita ou cancelada por ele mesmo
                         else if (payload.eventType === 'UPDATE' && oldRecord.status === 'assigned' && ['accepted', 'canceled_by_driver'].includes(newRecord.status)) {
                             stopRinging();
                         }
                         // Garante que o alarme pare se não houver mais corridas 'assigned' para este motorista
                         const hasOtherAssignedJob = state.rides.some(r => r.driverId === state.currentDriverId && r.status === 'assigned');
                         if (!hasOtherAssignedJob) {
                             stopRinging();
                         }
                    }


                    // Atualiza a UI se a tela relevante estiver ativa
                    const activeScreenId = document.querySelector('.screen.active')?.id;
                    if (activeScreenId === 'driver-screen' && state.currentDriverId === relevantDriverId) {
                        console.log('Refreshing driver jobs list due to real-time update.');
                        loadDriverJobs(); // Atualiza a lista do motorista logado
                    } else if (activeScreenId === 'driver-selection-screen') {
                         console.log('Refreshing driver selection list due to real-time update.');
                        populateDriverSelection(); // Atualiza a lista de seleção
                    }
                }
            )
            .subscribe((status, err) => {
                if (status === 'SUBSCRIBED') { console.log('Subscribed to real-time rides!'); }
                if (err) { console.error('Rides subscription error:', err); }
            });

            // Subscription para motoristas
            supabaseClient.channel('public:drivers').on('postgres_changes', { event: '*', schema: 'public', table: 'drivers' }, async (payload) => {
                console.log('Real-time event received (drivers):', payload.eventType);
                await fetchAllData(); // Atualiza lista de motoristas
                const activeScreenId = document.querySelector('.screen.active')?.id;
                if (activeScreenId === 'driver-selection-screen') {
                    populateDriverSelection();
                }
                // Atualiza o botão de status se o motorista afetado for o logado
                if (activeScreenId === 'driver-screen' && state.currentDriverId && (payload.new?.id === state.currentDriverId || payload.old?.id === state.currentDriverId)) {
                    updateDriverStatusButton();
                }
            }).subscribe((status, err) => {
                 if (status === 'SUBSCRIBED') { console.log('Subscribed to real-time drivers!'); }
                 if (err) { console.error('Drivers subscription error:', err); }
            });
        }


        // --- initApp --- (Garante que seja chamado após DOM carregado)
        async function initApp() {
            loadRideProgress(); // Carrega progresso salvo
            loadAppIcon();      // Carrega o ícone do app
            await fetchAllData(); // Busca dados iniciais
            setupRealtimeSubscriptions(); // Configura atualizações em tempo real

            // Listener para quando a aba/app volta a ficar visível
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    console.log("App visível. Sincronizando dados e Wake Lock...");
                    // Tenta reativar o Wake Lock se o toggle estiver marcado
                    if (document.getElementById('wake-lock-toggle').checked) {
                         await requestWakeLock();
                    }
                    // Busca os dados mais recentes
                    await fetchAllData();
                    // Atualiza a UI da tela ativa
                    const activeScreen = document.querySelector('.screen.active');
                    if (activeScreen?.id === 'driver-screen') {
                        loadDriverJobs();
                    } else if (activeScreen?.id === 'driver-selection-screen') {
                        populateDriverSelection();
                    }
                }
            });

            // Verifica se há um motorista logado no localStorage
            const loggedInDriverId = localStorage.getItem('loggedInDriverId');
            if (loggedInDriverId) {
                state.currentDriverId = parseInt(loggedInDriverId);
                const driver = state.drivers.find(d => d.id === state.currentDriverId);
                if (driver) {
                    // Se encontrou o motorista, vai para a tela dele
                    document.getElementById('driver-name-display').textContent = `Bem-vindo, ${driver.name}`;
                    requestNotificationPermission(); // Pede permissão aqui tbm, caso não tenha dado antes
                    showScreen('driver-screen');
                } else {
                    // Se o ID salvo é inválido, limpa e vai para a inicial
                    console.warn("ID do motorista salvo inválido. Deslogando.");
                    localStorage.removeItem('loggedInDriverId');
                    state.currentDriverId = null;
                    showScreen('initial-screen');
                }
            } else {
                // Se não há motorista logado, mostra a tela inicial
                showScreen('initial-screen');
            }
        }

        // --- loadAppIcon --- (sem alterações)
        function loadAppIcon() {
            const iconContainer = document.getElementById('app-icon-container');
            iconContainer.innerHTML = ''; // Limpa antes de adicionar
            if (state.appIcon) {
                const img = document.createElement('img');
                img.src = state.appIcon;
                img.className = 'h-12 w-12 object-contain';
                img.alt = 'App Icon';
                iconContainer.appendChild(img);
            }
        }

        // --- translateStatus --- (sem alterações)
        function translateStatus(status) {
            const statuses = {
                'assigned': 'DESIGNADO', 'accepted': 'ACEITO', 'arrived_pickup': 'CHEGOU NO EMBARQUE', 'in_progress': 'EM ANDAMENTO', 'completed': 'FINALIZADA', 'canceled': 'CANCELADA', 'canceled_by_driver': 'CANCELADO PELO MOTORISTA', 'scheduled': 'AGENDADA', // Adicionado
                'pending_approval': 'PEND. APROVAÇÃO', // Adicionado
                'approved': 'APROVADA', // Adicionado
                'rejected': 'REJEITADA' // Adicionado
            };
            return statuses[status] || status.toUpperCase();
        }

        // --- exportRidesToPdf --- (sem alterações)
        function exportRidesToPdf() {
            // Verifica se jsPDF está carregado
             if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                 showModal("Erro ao carregar a biblioteca PDF. Tente recarregar a página.");
                 console.error("jsPDF não está definido.");
                 return;
             }
             if (typeof doc.autoTable !== 'function') {
                  showModal("Erro ao carregar o plugin AutoTable do PDF. Tente recarregar a página.");
                 console.error("jsPDF AutoTable não está definido.");
                 return;
             }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const startDateInput = document.getElementById('start-date').value;
            const endDateInput = document.getElementById('end-date').value;

            if (!startDateInput || !endDateInput) {
                showModal("Por favor, selecione a data inicial e a data final.");
                return;
            }

            // Define as datas com hora específica para incluir o dia inteiro
            const startDate = new Date(startDateInput + 'T00:00:00-03:00'); // Fuso -03:00 (Brasil)
            const endDate = new Date(endDateInput + 'T23:59:59-03:00');

            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                 showModal("Datas inválidas selecionadas.");
                 return;
            }

            if (startDate > endDate) {
                showModal("A data inicial não pode ser posterior à data final.");
                return;
            }

            // Filtra as corridas do motorista logado dentro do período
            const ridesToExport = state.rides.filter(r => {
                if (r.driverId !== state.currentDriverId) return false;
                let rideDate;
                 try {
                     rideDate = new Date(r.requestTime); // Usa requestTime como referência
                     if (isNaN(rideDate.getTime())) return false; // Ignora datas inválidas
                 } catch(e) { return false; }

                return rideDate >= startDate && rideDate <= endDate;
            });

            if (ridesToExport.length === 0) {
                showModal("Nenhum histórico de corrida encontrado para o período selecionado.");
                return;
            }

            const driver = state.drivers.find(d => d.id === state.currentDriverId);
            const driverName = driver ? driver.name : 'Motorista Desconhecido';
            const period = `${startDate.toLocaleDateString('pt-BR')} a ${endDate.toLocaleDateString('pt-BR')}`;

            // --- Cabeçalho do PDF ---
            doc.setFontSize(16);
            doc.text('Relatório de Corridas', 14, 22);
            doc.setFontSize(11);
            doc.setTextColor(100); // Cinza
            doc.text(`Motorista: ${driverName}`, 14, 30);
            doc.text(`Período: ${period}`, 14, 36);

            // --- Tabela ---
            const tableColumn = ["Data/Hora", "Usuário", "Origem", "Destino(s)", "Status"];
            const tableRows = [];

            // Ordena por data antes de adicionar à tabela
            ridesToExport.sort((a, b) => new Date(a.requestTime) - new Date(b.requestTime));

            ridesToExport.forEach(ride => {
                const rideDateTime = new Date(ride.requestTime).toLocaleString('pt-BR');
                const destinations = parseDestinations(ride.destination).join('; '); // Junta destinos parseados
                const rideData = [
                    rideDateTime,
                    ride.userName || 'N/A',
                    ride.origin_address || 'N/A', // Adiciona origem
                    destinations || 'N/A',
                    translateStatus(ride.status)
                ];
                tableRows.push(rideData);
            });

            // Gera a tabela no PDF
            doc.autoTable({
                head: [tableColumn],
                body: tableRows,
                startY: 45, // Posição inicial da tabela
                theme: 'striped', // Estilo da tabela
                headStyles: { fillColor: [41, 128, 185] }, // Cor do cabeçalho
            });

            // --- Rodapé (Opcional) ---
            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(150);
                doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width - 30, doc.internal.pageSize.height - 10);
                 doc.text(`Gerado em: ${new Date().toLocaleString('pt-BR')}`, 14, doc.internal.pageSize.height - 10);
            }

            // Salva o PDF
            doc.save(`relatorio_corridas_${driverName.replace(/\s/g, '_')}_${startDateInput}_a_${endDateInput}.pdf`);
            closeExportModal(); // Fecha o modal após gerar
        }

        // Chama initApp quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

    </body>
</html>