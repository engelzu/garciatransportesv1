<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GARCIA TRANSPORTES</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@geoapify/geocoder-autocomplete@2.0.1/dist/themes/minimal.css" />
    <script src="https://cdn.jsdelivr.net/npm/@geoapify/geocoder-autocomplete@2.0.1/dist/index.min.js"></script>
    <style>
        body, html {
            background-color: #000;
        }
        .main-gradient {
            background: linear-gradient(135deg, #000000, #000000);
        }
        .button-gradient {
            background: linear-gradient(to right, #000000, #000000);
            border: 2px solid white;
            position: relative;
            overflow: hidden;
        }
        .button-gradient::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(255,255,255,0.3), rgba(255,255,255,0));
            transition: transform 0.3s ease-in-out;
            transform: translateX(-100%);
        }
        .button-gradient:hover::before {
            transform: translateX(0);
        }

        .button-gradient:disabled {
            background: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .card-gradient {
             background: linear-gradient(135deg, #000000, #000000);
        }
        .screen {
            display: none;
            background-color: #000;
        }
        .screen.active {
            display: block;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #6d28d9;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ESTILO PARA O AUTOCOMPLETE DO GEOAPIFY */
        .geoapify-autocomplete-input {
             color: white !important;
             background-color: #374151 !important; /* Fundo do input */
             border: 1px solid #4b5563 !important;
             padding: 0.75rem !important; /* Equivalente ao p-3 */
             border-radius: 0.5rem !important; /* Equivalente ao rounded-lg */
        }
        .geoapify-autocomplete-items {
            background-color: #374151 !important; /* Fundo da lista dropdown */
            border: 1px solid #4b5563 !important;
            color: white !important;
            z-index: 1000; /* Garante que fique sobre outros elementos */
        }
        .geoapify-autocomplete-items div:hover {
            background-color: #4b5563 !important; /* Cor do item em hover */
        }
        .geoapify-autocomplete-item {
             color: white !important;
             padding: 10px !important;
             font-size: 14px !important;
        }
        .geoapify-autocomplete-item.active {
            background-color: #4f46e5 !important; /* Cor do item selecionado */
        }
        /* Ajuste container */
        .autocomplete-container {
            position: relative; /* Necessário para o dropdown */
        }
        /* FIM DO ESTILO DO AUTOCOMPLETE */

        #mobile-menu {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out, visibility 0.3s;
            visibility: hidden;
        }
        #mobile-menu.active {
            transform: translateX(0);
            visibility: visible;
        }
        .menu-backdrop {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .text-black { color: #ffffff !important; }
        .text-gray-800 { color: #ffffff !important; }
        .text-gray-400 { color: #ffffff !important; }
        .text-gray-300 { color: #ffffff !important; }
        .text-gray-600 { color: #ffffff !important; }
        .text-gray-700 { color: #ffffff !important; }
        .text-gray-500 { color: #ffffff !important; }
        .text-green-300 { color: #ffffff !important; }
        .text-yellow-300 { color: #ffffff !important; }
        .text-cyan-400 { color: #00ffff !important; }

        h1, h2, h3, p, button, label, input::placeholder, textarea::placeholder, select {
            color: #ffffff !important;
        }

        input, select, textarea {
            background-color: #374151 !important;
            border-color: #4b5563 !important;
        }

        .logout-button-green {
            background-color: #16a34a;
            border: 2px solid #16a34a;
            color: #ffffff !important;
        }
        .logout-button-green:hover {
            background-color: #15803d;
            border-color: #15803d;
        }

        #menu-toggle-btn svg path {
            stroke: #ffffff !important;
        }

        #user-login-screen button:first-child {
            color: #ffffff !important;
        }

        .content-wrapper {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
        }

        .input-and-button-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        #destination { /* Este ID não existe mais diretamente, mas mantemos caso precise */
            width: 100%;
            box-sizing: border-box;
        }

        #request-ride-btn {
            width: 100%;
            box-sizing: border-box;
        }

        #intro-video {
            width: 100%;
            height: 100vh;
            object-fit: cover;
        }

        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #passenger-icon {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        #user-id, #user-password {
            font-size: 14px;
            text-align: center;
        }
        #user-id::placeholder, #user-password::placeholder {
            text-align: center;
        }
    </style>
</head>
<body class="main-gradient text-white min-h-screen flex items-center justify-center p-4">

    <audio id="arrival-sound" src="som/somchamada.mp3" preload="auto"></audio>

    <div id="video-container">
        <video id="intro-video" autoplay muted playsinline>
            <source src="images/video1.mp4" type="video/mp4">
            Seu navegador não suporta o elemento de vídeo.
        </video>
    </div>

    <div id="menu-backdrop" class="fixed inset-0 z-40 hidden menu-backdrop" onclick="toggleMenu()"></div>
    <div id="mobile-menu" class="fixed top-0 right-0 h-full w-64 card-gradient p-6 z-50">
        <div class="flex justify-end mb-8">
            <button onclick="toggleMenu()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
        <nav class="flex flex-col justify-between h-[calc(100%-5rem)]">
            <ul>
                <li class="mb-4">
                    <button onclick="showHistoryModal(); toggleMenu()" class="block w-full text-left py-2 px-4 rounded-lg hover:bg-gray-700">Minhas Solicitações</button>
                </li>
                 <li class="mb-4">
                    <button onclick="exportUserRidesToExcel(); toggleMenu()" class="block w-full text-left py-2 px-4 rounded-lg hover:bg-gray-700">Exportar Histórico</button>
                </li>
            </ul>
        </nav>
    </div>

    <div id="app-container" class="w-full max-w-md mx-auto relative hidden">

        <div id="initial-screen" class="screen active text-center">
            <div class="flex flex-col items-center justify-center mb-4">
                <div id="app-icon-container" class="h-28 w-28 mb-2"></div>
            </div>
            <h1 class="text-4xl sm:text-5xl font-bold text-black mb-2">GARCIA TRANSPORTES</h1>
            <p class="mb-12 text-gray-800">Sua viagem segura e rápida.</p>
            <div class="space-y-4">
                <button onclick="showScreen('user-login-screen')" class="w-full flex items-center justify-center gap-3 py-4 px-6 text-lg font-semibold rounded-lg button-gradient shadow-lg transform hover:scale-105 transition-transform">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-sky-300" fill="none" viewBox="0 0 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                    </svg>
                    PASSAGEIRO
                </button>
            </div>
        </div>

        <div id="user-login-screen" class="screen">
            <button onclick="showScreen('initial-screen')" class="mb-4 text-yellow-300">&larr; Voltar</button>

            <img src="images/icone_passageiro.png" alt="Ícone do Passageiro" class="mx-auto" style="width: 80px; height: 80px; object-fit: contain; margin-bottom: 1rem;">

            <h2 class="text-3xl font-bold mb-6 text-center">Login do Passageiro</h2>
            <div class="mb-4">
                <label for="user-id" class="block mb-2 text-sm font-medium">Matrícula</label>
                <input type="text" id="user-id" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none" placeholder="Digite sua matrícula">
            </div>
            <div class="mb-4">
                <label for="user-password" class="block mb-2 text-sm font-medium">Senha</label>
                <input type="password" id="user-password" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none" placeholder="Digite sua senha">
            </div>
            <button onclick="loginUser()" class="w-full py-3 px-6 text-lg font-semibold rounded-lg button-gradient shadow-lg">ENTRAR</button>
            <p id="user-login-error" class="text-red-500 text-center mt-4 hidden">Matrícula ou senha incorreta!</p>
        </div>

        <div id="user-screen" class="screen">
            <div class="flex flex-col items-center justify-center mb-6">
                <img id="cheguei-image" src="images/final.png" alt="Motorista Chegou" class="h-28 w-28 object-contain mb-4 hidden">
            </div>

            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center gap-3">
                    <img id="passenger-icon" src="images/icone_passageiro.png" alt="Ícone do Passageiro">
                    <h2 class="text-2xl font-bold">Área do Passageiro</h2>
                </div>
                <button id="menu-toggle-btn" onclick="toggleMenu()" class="lg:hidden p-2 text-gray-300 hover:text-white focus:outline-none">
                    <svg class="h-8 w-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>
            <p id="user-welcome-message" class="text-center text-xl text-gray-300 mb-4"></p>

            <div id="permission-denied-message" class="hidden card-gradient p-4 rounded-lg mb-6 text-center text-yellow-300 border-2 border-yellow-400">
                <p class="font-semibold text-lg">Permissão para solicitar corridas desabilitada.</p>
                <p class="text-sm">Apenas um administrador pode solicitar uma viagem para você. Acompanhe o status aqui.</p>
            </div>
                        <div id="user-status" class="hidden mt-8 text-center card-gradient p-4 rounded-lg mb-6">
                <div id="status-icon-searching" class="hidden mx-auto mb-2">
                    <div class="loader mx-auto"></div>
                </div>
                <div id="status-icon-en-route" class="hidden mx-auto mb-2"></div>
                <div id="status-icon-arrived-pickup" class="hidden mx-auto mb-2"></div>
                <div id="status-icon-in-progress" class="hidden mx-auto mb-2"></div>

                <p id="user-status-message" class="mt-4 text-lg"></p>
                <button id="silence-alert-btn" onclick="silenceAlert()" class="hidden mt-4 w-full py-2 px-4 font-semibold rounded-lg bg-blue-600 hover:bg-blue-700">SILENCIAR ALERTA</button>
                <button id="edit-schedule-btn" onclick="openEditScheduleModal(state.currentUserRideId)" class="hidden mt-4 w-full py-2 px-4 font-semibold rounded-lg bg-yellow-500 hover:bg-yellow-600">ALTERAR AGENDAMENTO</button>
                <button id="cancel-ride-btn" onclick="cancelRide()" class="mt-4 w-full py-2 px-4 font-semibold rounded-lg bg-red-600 hover:bg-red-700">CANCELAR SOLICITAÇÃO</button>
            </div>

            <div id="user-request-form" class="card-gradient p-4 rounded-lg mb-6 content-wrapper">
                 <h3 class="text-center font-semibold mb-4 text-xl">Solicitar uma Viagem</h3>

                <div class="mb-4 input-and-button-container autocomplete-container">
                    <label for="origin" class="block mb-2 text-sm font-medium">Origem <span class="text-red-400">(Obrigatório)</span></label>
                    <input type="text" id="origin" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none" placeholder="Digite o endereço de partida">
                    <button onclick="useCurrentLocation()" class="mt-2 w-full py-2 px-4 text-sm font-semibold rounded-lg bg-sky-600 hover:bg-sky-700">Usar minha localização atual</button>
                </div>

                <div class="mb-4 input-and-button-container">
                    <label for="passenger-count" class="block mb-2 text-sm font-medium">Quantidade de Passageiros?</label>
                    <select id="passenger-count" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none">
                        <option value="1">1 Passageiro</option>
                        <option value="2">2 Passageiros</option>
                        <option value="3">3 Passageiros</option>
                        <option value="4">4 Passageiros</option>
                    </select>
                </div>

                <div id="destinations-container" class="w-full"></div>

                <div class="mb-4 input-and-button-container">
                    <label for="observation" class="block mb-2 text-sm font-medium">Observação (opcional)</label>
                    <textarea id="observation" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none" placeholder="Ex: Ponto de referência, necessidade especial..." maxlength="300" rows="3"></textarea>
                </div>

                <div class="input-and-button-container">
                    <button id="request-ride-btn" class="w-full py-3 px-6 text-lg font-semibold rounded-lg button-gradient shadow-lg transform hover:scale-105 transition-transform">
                        SOLICITAR TAXI
                    </button>
                </div>
            </div>

            <div class="mt-6">
                <button onclick="logoutUser()" class="w-full py-3 px-6 text-lg font-semibold rounded-lg shadow-lg transform hover:scale-105 transition-transform logout-button-green">
                    SAIR
                </button>
            </div>
        </div>

        <div id="request-type-screen" class="screen">
            <button onclick="showScreen('user-screen')" class="mb-8 text-yellow-300">&larr; Voltar</button>
            <h2 class="text-3xl font-bold mb-6 text-center">Tipo de Solicitação</h2>
            <div class="space-y-4">
                <button onclick="selectRequestType('immediate')" class="w-full flex items-center justify-center gap-3 py-4 px-6 text-lg font-semibold rounded-lg button-gradient shadow-lg transform hover:scale-105 transition-transform">
                    IMEDIATO
                </button>
                <button onclick="selectRequestType('scheduled')" class="w-full flex items-center justify-center gap-3 py-4 px-6 text-lg font-semibold rounded-lg button-gradient shadow-lg transform hover:scale-105 transition-transform">
                    AGENDAR
                </button>
            </div>
        </div>
    </div>

    <div id="modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4">
        <div class="card-gradient p-6 rounded-lg shadow-xl text-center w-full max-w-sm">
            <p id="modal-message" class="mb-4 text-lg"></p>
            <div id="modal-buttons" class="flex justify-center gap-4">
                 <button id="modal-cancel" onclick="closeModal('modal')" class="py-2 px-6 font-semibold rounded-lg bg-gray-500 hover:bg-gray-600">Cancelar</button>
                 <button id="modal-confirm" onclick="closeModal('modal')" class="py-2 px-8 font-semibold rounded-lg button-gradient">OK</button>
            </div>
        </div>
    </div>

    <div id="history-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4">
        <div class="card-gradient p-6 rounded-lg shadow-xl text-center w-full max-w-2xl max-h-[70vh] overflow-y-auto">
            <h3 class="text-2xl font-bold mb-4 text-center">Histórico de Corridas</h3>
            <div id="user-ride-history-modal" class="overflow-y-auto mb-6"></div>
            <div class="flex justify-center">
                <button onclick="closeModal('history-modal');" class="py-2 px-6 font-semibold rounded-lg bg-gray-600 hover:bg-gray-700">Fechar</button>
            </div>
        </div>
    </div>

    <div id="schedule-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4">
        <div class="card-gradient p-6 rounded-lg shadow-xl text-center w-full max-w-sm">
            <h3 class="text-2xl font-bold mb-4">Agendar Corrida</h3>
            <div class="mb-4 text-left">
                <label for="schedule-date" class="block mb-2 text-sm font-medium">Data</label>
                <input type="date" id="schedule-date" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none">
            </div>
            <div class="mb-6 text-left">
                <label for="schedule-time" class="block mb-2 text-sm font-medium">Hora</label>
                <input type="time" id="schedule-time" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none">
            </div>
            <div class="flex justify-center gap-4">
                <button onclick="closeModal('schedule-modal')" class="py-2 px-6 font-semibold rounded-lg bg-gray-500 hover:bg-gray-600">Cancelar</button>
                <button onclick="confirmSchedule()" class="py-2 px-8 font-semibold rounded-lg button-gradient">AGENDAR</button>
            </div>
        </div>
    </div>


    <script>
        // ========================================================================
        // NOVA CONSTANTE - CHAVE DA API GEOAPIFY
        // ========================================================================
        const GEOAPIFY_API_KEY = '3bd73ecada1d478a8c9473ad4115be38';

        // --- CONFIGURAÇÃO INICIAL E ESTADO DA APLICAÇÃO ---
        let state = {
            rides: [],
            users: [],
            appIcon: 'images/user.png',
            currentUserRideId: localStorage.getItem('currentUserRideId') || null, // Carrega o ID da corrida do storage
            currentUser: null,
            userStatusInterval: null,
            // Armazena os dados do local selecionado pelo autocomplete
            selectedOrigin: null,
            selectedDestinationsData: [] // Array para guardar dados dos destinos
        };

        // As variáveis abaixo não são mais diretamente do estado, mas controlam o fluxo da *próxima* requisição
        let selectedObservation = '';
        let selectedRequestType = '';
        let scheduledDateTime = null;
        let isProcessingRequest = false;

        // --- CONFIGURAÇÃO DO SUPABASE ---
        const SUPABASE_URL = 'https://jowsbmuqbzxukbbxbeqv.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impvd3NibXVxYnp4dWtiYnhiZXF2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU0NzA5NjQsImV4cCI6MjA3MTA0Njk2NH0.UMW2aQmuq0RiEHgody5StKEQzDjrKZnfUprDgDaMd1w';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- LÓGICA DE MODAL --- (sem alterações)
        function showModal(modalId, htmlContent, onConfirmCallback, showCancelButton = false) {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            const messageEl = modal.querySelector('#modal-message');
            if(messageEl && typeof htmlContent === 'string') {
                messageEl.textContent = htmlContent;
            }

            const confirmBtn = modal.querySelector('#modal-confirm');
            const cancelBtn = modal.querySelector('#modal-cancel');

            if (confirmBtn) {
                confirmBtn.onclick = () => {
                    if (onConfirmCallback) onConfirmCallback();
                    closeModal(modalId);
                };
            }

            if (cancelBtn) {
                cancelBtn.style.display = showCancelButton ? 'inline-block' : 'none';
                if(showCancelButton) {
                    cancelBtn.onclick = () => closeModal(modalId);
                }
            }

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function closeModal(modalId = 'modal') {
            const modal = document.getElementById(modalId);
            if (!modal) return;

            modal.classList.add('hidden');
            modal.classList.remove('flex');

            if (modalId === 'schedule-modal') {
                const confirmBtn = modal.querySelector('button.button-gradient');
                confirmBtn.textContent = 'AGENDAR';
                confirmBtn.onclick = confirmSchedule;
            }
        }

        // --- LÓGICA DO MENU SANDUÍCHE --- (sem alterações)
        function toggleMenu() {
            const menu = document.getElementById('mobile-menu');
            const backdrop = document.getElementById('menu-backdrop');
            menu.classList.toggle('active');
            backdrop.classList.toggle('hidden');
        }

        // --- LÓGICA DE LOGIN --- (sem alterações)
        async function loginUser() {
            const matricula = document.getElementById('user-id').value.trim();
            const password = document.getElementById('user-password').value.trim();
            const errorEl = document.getElementById('user-login-error');

            if (!matricula || !password) {
                errorEl.textContent = 'Por favor, preencha todos os campos.';
                errorEl.classList.remove('hidden');
                return;
            }

            const { data: user, error } = await supabaseClient
                .from('users')
                .select('*')
                .eq('matricula', matricula)
                .eq('password', password)
                .single();

            if (error && error.code !== 'PGRST116') {
                console.error('Erro no Supabase ao tentar login:', error);
                errorEl.textContent = 'Erro de comunicação com o servidor. Por favor, tente novamente.';
                errorEl.classList.remove('hidden');
                return;
            }

            if (user) {
                state.currentUser = user;
                localStorage.setItem('loggedInUser', JSON.stringify(user));
                document.getElementById('user-welcome-message').textContent = `Olá, ${user.name}!`;

                errorEl.classList.add('hidden');
                document.getElementById('user-id').value = '';
                document.getElementById('user-password').value = '';

                // Reseta variáveis de controle de requisição ao logar
                state.selectedOrigin = null;
                state.selectedDestinationsData = [];
                selectedObservation = '';
                selectedRequestType = '';
                scheduledDateTime = null;
                isProcessingRequest = false;

                await checkUserRideStatus();
                showScreen('user-screen');
            } else {
                errorEl.textContent = 'Matrícula ou senha incorreta!';
                errorEl.classList.remove('hidden');
            }
        }

        function logoutUser() {
            state.currentUser = null;
            state.currentUserRideId = null;
            localStorage.removeItem('loggedInUser');
            localStorage.removeItem('currentUserRideId');
            localStorage.removeItem('lastScreen');
            if (state.userStatusInterval) {
                clearInterval(state.userStatusInterval);
                state.userStatusInterval = null;
            }

            document.getElementById('user-welcome-message').textContent = '';
            document.getElementById('user-request-form').classList.remove('hidden');
            document.getElementById('user-status').classList.add('hidden');

            // Limpa os dados de locais selecionados
            state.selectedOrigin = null;
            state.selectedDestinationsData = [];

            showScreen('initial-screen');
        }

        // --- NAVEGAÇÃO ENTRE TELAS --- (sem alterações lógicas, apenas adiciona autocomplete)
        function updateUserScreenView() {
            const requestForm = document.getElementById('user-request-form');
            const permissionMessage = document.getElementById('permission-denied-message');
            const userStatusDiv = document.getElementById('user-status');
            const hasActiveRide = userStatusDiv && !userStatusDiv.classList.contains('hidden');

            if (state.currentUser && state.currentUser.can_request_ride === false) {
                requestForm.classList.add('hidden');
                permissionMessage.classList.remove('hidden');
            } else {
                permissionMessage.classList.add('hidden');
                if (!hasActiveRide) {
                    requestForm.classList.remove('hidden');
                } else {
                    requestForm.classList.add('hidden'); // Esconde o form se tiver corrida ativa
                }
            }
        }

        async function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            const activeScreen = document.getElementById(screenId);
            if (activeScreen) {
                activeScreen.classList.add('active');
            }

            if (['initial-screen', 'user-login-screen', 'user-screen'].includes(screenId)) {
                localStorage.setItem('lastScreen', screenId);
            }

            if (screenId === 'user-screen' && state.currentUser) {
                updateUserScreenView();
                await checkUserRideStatus();
                // Inicializa o autocomplete nos campos de endereço da tela do usuário
                initAutocomplete(document.getElementById('origin'), (feature) => {
                    state.selectedOrigin = feature; // Guarda os dados do local selecionado
                });
                updateDestinationFields(document.getElementById('passenger-count').value); // Reinicializa autocompletes dos destinos
            } else if (state.userStatusInterval) {
                clearInterval(state.userStatusInterval);
                state.userStatusInterval = null;
            }

            if (document.getElementById('mobile-menu').classList.contains('active')) {
                toggleMenu();
            }
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - useCurrentLocation (Usa Geoapify Reverse Geocoding)
        // ========================================================================
        async function useCurrentLocation() {
            const originInput = document.getElementById('origin');
            originInput.disabled = true;
            originInput.value = 'Obtendo localização...';

            if (!navigator.geolocation) {
                showModal('modal', 'Geolocalização não é suportada pelo seu navegador.');
                originInput.value = '';
                originInput.disabled = false;
                return;
            }

            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
                });

                const lat = position.coords.latitude;
                const lon = position.coords.longitude;

                // Chama a API Reverse Geocoding do Geoapify
                const url = `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lon}&lang=pt&apiKey=${GEOAPIFY_API_KEY}`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.features && data.features.length > 0) {
                    const address = data.features[0].properties.formatted;
                    originInput.value = address;
                    // Salva os dados do local (incluindo lat/lon) no state
                    state.selectedOrigin = data.features[0];
                } else {
                    showModal('modal', 'Nenhum endereço encontrado para sua localização.');
                    originInput.value = '';
                    state.selectedOrigin = null;
                }

            } catch (error) {
                let userMessage = "Não foi possível obter sua localização. Verifique as permissões do navegador.";
                if (error && error.code) {
                    switch (error.code) {
                        case 1: userMessage = "Você negou a permissão de localização."; break;
                        case 2: userMessage = "Informações de localização não estão disponíveis."; break;
                        case 3: userMessage = "A solicitação para obter a localização expirou."; break;
                    }
                }
                showModal('modal', userMessage);
                console.error('Erro detalhado ao obter localização:', error);
                originInput.value = '';
                state.selectedOrigin = null;
            } finally {
                originInput.disabled = false;
            }
        }

        // --- LÓGICA DE SOLICITAÇÃO DE CORRIDA --- (funções selectRequestType, openScheduleModal, confirmSchedule permanecem as mesmas)
        function selectRequestType(type) {
            selectedRequestType = type;

            if (type === 'immediate') {
                requestRide();
            } else if (type === 'scheduled') {
                openScheduleModal();
            }
        }

        function openScheduleModal() {
            const modal = document.getElementById('schedule-modal');
            const today = new Date();
            document.getElementById('schedule-date').min = new Date().toISOString().split('T')[0];
            document.getElementById('schedule-date').value = today.toISOString().split('T')[0];
            document.getElementById('schedule-time').value = today.toTimeString().slice(0, 5);

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function confirmSchedule() {
            const dateInput = document.getElementById('schedule-date');
            const timeInput = document.getElementById('schedule-time');

            if (!dateInput.value || !timeInput.value) {
                showModal('modal', 'Por favor, selecione uma data e hora para agendamento.');
                return;
            }

            const scheduledDate = new Date(`${dateInput.value}T${timeInput.value}`);
            if (scheduledDate < new Date()) {
                showModal('modal', 'A data e hora do agendamento não podem ser no passado.');
                return;
            }

            scheduledDateTime = scheduledDate.toISOString();

            closeModal('schedule-modal');
            requestRide();
        }

        function resetRequestButton() {
            const requestRideBtn = document.getElementById('request-ride-btn');
            requestRideBtn.disabled = false;
            requestRideBtn.textContent = 'SOLICITAR TAXI';
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - requestRide (Usa dados do state e não geocodifica mais)
        // ========================================================================
        async function requestRide() {
            if (isProcessingRequest) return;
            showScreen('user-screen'); // Garante que a tela correta esteja visível

            const originInput = document.getElementById('origin');
            const originAddress = originInput.value.trim();
            const passengerCount = document.getElementById('passenger-count').value;
            const requestRideBtn = document.getElementById('request-ride-btn');

            // 1. Validação usando os dados salvos no state pelo autocomplete
            if (!state.selectedOrigin || state.selectedOrigin.properties.formatted !== originAddress) {
                showModal('modal', 'Endereço de ORIGEM inválido. Por favor, selecione um da lista de sugestões.');
                return;
            }

            // Pega os destinos dos inputs E verifica se os dados correspondentes estão no state.selectedDestinationsData
            const destinations = [];
            let firstDestinationValid = false;
            for (let i = 0; i < passengerCount; i++) {
                const destInput = document.getElementById(`destination-${i + 1}`);
                const destAddress = destInput ? destInput.value.trim() : '';
                destinations.push(destAddress); // Guarda o endereço como string

                // Verifica se o endereço digitado corresponde a um local selecionado
                const selectedData = state.selectedDestinationsData[i];
                if (i === 0) { // Destino 1 é obrigatório e precisa ser validado
                    if (!destAddress || !selectedData || selectedData.properties.formatted !== destAddress) {
                        showModal('modal', `Endereço do DESTINO ${i+1} inválido. Por favor, selecione um da lista de sugestões.`);
                        return;
                    }
                    firstDestinationValid = true;
                } else if (destAddress && (!selectedData || selectedData.properties.formatted !== destAddress)) {
                    // Se digitou algo no destino 2+ mas não selecionou da lista
                     showModal('modal', `Endereço do DESTINO ${i+1} inválido. Por favor, selecione um da lista de sugestões ou deixe em branco se não aplicável.`);
                    return;
                }
            }

            if (!firstDestinationValid) {
                 showModal('modal', 'O destino do primeiro passageiro é obrigatório e precisa ser selecionado da lista.');
                 return;
            }

            const observation = document.getElementById('observation').value.trim();

            if (state.currentUserRideId) {
                showModal('modal', 'Você já possui uma solicitação de corrida ativa.');
                return;
            }

            isProcessingRequest = true;
            requestRideBtn.disabled = true;
            requestRideBtn.textContent = 'Processando...';

            try {
                // Não precisa mais geocodificar aqui, já temos lat/lon da origem
                const originCoords = state.selectedOrigin.properties; // lon, lat
                const userLocation = { lat: originCoords.lat, lon: originCoords.lon };
                const currentUser = state.currentUser;

                if (!currentUser) {
                    throw new Error('Usuário não encontrado. Por favor, faça login novamente.');
                }

                // Prepara os dados do destino para salvar no banco
                // Salvaremos apenas os endereços formatados como strings
                const destinationStrings = state.selectedDestinationsData
                    .map(destData => destData ? destData.properties.formatted : '') // Pega o endereço formatado
                    .filter(Boolean); // Remove vazios (se algum destino não foi preenchido)

                let newRideData = {
                    origin_address: originAddress,
                    // Salva os endereços formatados como um array de strings JSON
                    destination: JSON.stringify(destinationStrings),
                    observation: observation,
                    passenger_count: parseInt(passengerCount),
                    status: 'pending_approval', // Sempre começa como pendente
                    userId: currentUser.id,
                    userName: currentUser.name,
                    userCompany: currentUser.company,
                    requestTime: new Date().toISOString(),
                    userLocation: userLocation, // Salva {lat, lon}
                    request_type: selectedRequestType
                };

                if (selectedRequestType === 'scheduled' && scheduledDateTime) {
                    newRideData.scheduled_datetime = scheduledDateTime;
                    // Mantém pending_approval mesmo se agendado
                }

                const { data, error } = await supabaseClient.from('rides').insert([newRideData]).select().single();

                if (error) {
                    throw new Error('Não foi possível solicitar a corrida: ' + error.message);
                }

                state.currentUserRideId = data.id;
                localStorage.setItem('currentUserRideId', data.id);

                // Limpa o formulário e os dados temporários
                document.getElementById('origin').value = '';
                document.getElementById('passenger-count').value = 1;
                updateDestinationFields(1); // Limpa e reseta os campos de destino
                document.getElementById('observation').value = '';
                state.selectedOrigin = null;
                state.selectedDestinationsData = [];
                selectedObservation = '';
                selectedRequestType = '';
                scheduledDateTime = null;

                await checkUserRideStatus(); // Atualiza a tela para mostrar o status

            } catch (error) {
                console.error("Erro detalhado no processo de solicitação:", error);
                showModal('modal', error.message || 'Ocorreu um erro inesperado ao processar sua solicitação.');
                // Não reseta o botão aqui, deixa o usuário ver o erro
            } finally {
                // Reseta o botão apenas se a requisição não estiver mais processando
                // (pode ter falhado ou sucedido)
                isProcessingRequest = false;
                resetRequestButton();
            }
        }


        // --- Funções checkUserRideStatus, startUserStatusCheck, updateUserStatusMessage, cancelRide ---
        // Nenhuma alteração necessária aqui, elas já lidam com os dados do Supabase.

        async function checkUserRideStatus() {
            if (!state.currentUser) return;

            const requestForm = document.getElementById('user-request-form');
            const userStatusDiv = document.getElementById('user-status');
            const chegueiImage = document.getElementById('cheguei-image');

            // Tenta pegar o ID da corrida do localStorage primeiro
            const storedRideId = localStorage.getItem('currentUserRideId');
            let rideToCheckId = state.currentUserRideId || storedRideId;

            let activeRide = null;
            let error = null;

            // Se temos um ID, verificamos se essa corrida específica ainda está ativa
            if (rideToCheckId) {
                const { data, error: fetchError } = await supabaseClient
                    .from('rides')
                    .select('*')
                    .eq('id', rideToCheckId)
                    .in('status', ['pending_approval', 'approved', 'rejected', 'requested', 'assigned', 'accepted', 'arrived_pickup', 'in_progress', 'scheduled'])
                    .maybeSingle(); // Use maybeSingle para não dar erro se não encontrar
                 activeRide = data;
                 error = fetchError;
            }

            // Se não encontrou uma corrida ativa pelo ID armazenado, ou se não havia ID,
            // faz uma busca mais geral por qualquer corrida ativa do usuário
            if (!activeRide && !error) {
                 const { data, error: fetchError } = await supabaseClient
                    .from('rides')
                    .select('*')
                    .eq('userId', state.currentUser.id)
                    .in('status', ['pending_approval', 'approved', 'rejected', 'requested', 'assigned', 'accepted', 'arrived_pickup', 'in_progress', 'scheduled'])
                    .order('created_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();
                 activeRide = data;
                 error = fetchError;
            }


            if (error) {
                 console.error("Erro ao buscar corrida ativa:", error);
                 // Continua para o estado sem corrida ativa
            }


            if (activeRide && activeRide.status !== 'rejected') {
                state.currentUserRideId = activeRide.id;
                localStorage.setItem('currentUserRideId', activeRide.id); // Atualiza o ID correto

                requestForm.classList.add('hidden');
                userStatusDiv.classList.remove('hidden');
                await updateUserStatusMessage(activeRide);

                if (activeRide.status === 'arrived_pickup') {
                    chegueiImage.classList.remove('hidden');
                } else {
                    chegueiImage.classList.add('hidden');
                }

                startUserStatusCheck();
            } else {
                if(activeRide && activeRide.status === 'rejected'){
                    const seenRejectedId = localStorage.getItem('seenRejectedRideId');
                    if (String(activeRide.id) !== seenRejectedId) {
                        showModal('modal', 'Sua solicitação de corrida não foi aprovada pela sua empresa.', () => {
                            localStorage.setItem('seenRejectedRideId', activeRide.id);
                        });
                    }
                }
                state.currentUserRideId = null;
                localStorage.removeItem('currentUserRideId');

                userStatusDiv.classList.add('hidden');
                updateUserScreenView(); // Mostra o formulário se permitido
                resetRequestButton();
                document.getElementById('user-status-message').textContent = '';
                chegueiImage.classList.add('hidden');

                if (state.userStatusInterval) {
                    clearInterval(state.userStatusInterval);
                    state.userStatusInterval = null;
                }
            }
        }

        function startUserStatusCheck() {
            if (state.userStatusInterval) clearInterval(state.userStatusInterval);

            state.userStatusInterval = setInterval(async () => {
                if (!state.currentUserRideId) {
                    clearInterval(state.userStatusInterval);
                    state.userStatusInterval = null;
                    await checkUserRideStatus();
                    return;
                }

                const { data: myRide, error } = await supabaseClient.from('rides').select('*').eq('id', state.currentUserRideId).single();

                if (myRide && !['completed', 'canceled', 'rejected'].includes(myRide.status)) {
                   await updateUserStatusMessage(myRide);
                } else {
                    clearInterval(state.userStatusInterval);
                    state.userStatusInterval = null;
                    const finalStatus = myRide ? translateStatus(myRide.status) : 'finalizada';
                    state.currentUserRideId = null;
                    localStorage.removeItem('currentUserRideId');
                    showModal('modal', `Sua corrida foi ${finalStatus}.`, checkUserRideStatus);
                }
            }, 10000);
        }

        function silenceAlert() {
            const arrivalSound = document.getElementById('arrival-sound');
            const silenceBtn = document.getElementById('silence-alert-btn');
            if (arrivalSound) {
                arrivalSound.pause();
                arrivalSound.currentTime = 0;
            }
            if (silenceBtn) {
                silenceBtn.classList.add('hidden');
            }
        }

        async function updateUserStatusMessage(ride) {
            const statusMessageEl = document.getElementById('user-status-message');
            const chegueiImage = document.getElementById('cheguei-image');
            const allIcons = document.querySelectorAll('#user-status [id^="status-icon-"]');
            allIcons.forEach(icon => icon.classList.add('hidden'));

            const cancelRideBtn = document.getElementById('cancel-ride-btn');
            const editScheduleBtn = document.getElementById('edit-schedule-btn');
            const silenceBtn = document.getElementById('silence-alert-btn');
            const arrivalSound = document.getElementById('arrival-sound');

            silenceBtn.classList.add('hidden');
            if (arrivalSound && !arrivalSound.paused) {
                arrivalSound.pause();
                arrivalSound.currentTime = 0;
            }

            let message = '';
            let scheduleInfo = '';
            let driverInfo = '';

            // Busca detalhes do motorista APENAS se necessário e ainda não carregados
            if (ride.driverId && ['assigned', 'accepted', 'arrived_pickup', 'in_progress'].includes(ride.status)) {
                // Você pode adicionar um cache simples aqui se quiser evitar buscas repetidas
                try {
                    const { data: driver, error: driverError } = await supabaseClient
                        .from('drivers') // Assumindo que a tabela é 'drivers'
                        .select('name, plate, car_model, car_color') // Pegue os campos relevantes
                        .eq('id', ride.driverId)
                        .single();

                    if (driverError) throw driverError;

                    if (driver) {
                        driverInfo = `
                            <div class="mt-4 p-3 bg-gray-800 rounded-lg text-left border border-gray-600">
                                <p class="font-semibold text-center text-lg mb-3 text-cyan-400">Motorista a caminho</p>
                                <p class="text-center text-xl font-bold mb-3">${ride.driverName || driver.name || 'N/A'}</p>
                                <div class="flex justify-between items-center">
                                    <div class="space-y-1 text-center flex-1">
                                        <p class="text-lg"><strong>Modelo:</strong> ${driver.car_model || 'N/A'}</p>
                                    </div>
                                    <div class="border-2 border-gray-400 rounded-lg py-1 px-3 flex flex-col items-center justify-center">
                                        <span class="text-base font-semibold">${(driver.car_color || 'N/A').toUpperCase()}</span>
                                        <div class="flex items-baseline space-x-2">
                                            <span class="text-base font-bold">PLACA</span>
                                            <span class="text-2xl font-bold tracking-wider">${driver.plate || 'N/A'}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Erro ao buscar detalhes do motorista:', error);
                    // Exibe apenas o nome se a busca falhar mas o nome existir na corrida
                    if (ride.driverName) {
                       driverInfo = `<div class="mt-4 p-3 bg-gray-800 rounded-lg text-sm border border-gray-600"><p class="font-semibold text-center text-lg mb-2 text-cyan-400">Motorista a caminho</p><p class="text-center text-xl font-bold">${ride.driverName}</p></div>`;
                    }
                }
            }


            if (ride.request_type === 'scheduled' && ride.scheduled_datetime) {
                const scheduledDate = new Date(ride.scheduled_datetime);
                const formattedScheduledDateTime = scheduledDate.toLocaleString('pt-BR', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                scheduleInfo = `<div class="mt-2 text-xl font-bold text-cyan-400">Agendado para:<br>${formattedScheduledDateTime}</div>`;
            }

            const getIcon = (id) => document.getElementById(`status-icon-${id}`);

            switch(ride.status) {
                case 'pending_approval':
                    message = 'Aguardando aprovação da sua empresa...';
                    getIcon('searching').classList.remove('hidden');
                    break;
                case 'approved': // Adicionado status aprovado
                case 'requested':
                    message = 'Procurando o melhor motorista para você...';
                    getIcon('searching').classList.remove('hidden');
                    break;
                case 'assigned':
                    message = `Motorista designado foi notificado. Aguardando aceite...`;
                    getIcon('searching').classList.remove('hidden');
                    break;
                case 'accepted':
                    message = `Seu motorista está a caminho!`;
                    getIcon('en-route').innerHTML = `<img src="images/aceitou.png" alt="Motorista Aceitou" class="h-20 w-20 mx-auto">`;
                    getIcon('en-route').classList.remove('hidden');
                    break;
                case 'arrived_pickup':
                    message = `Seu motorista chegou!`;
                    chegueiImage.classList.remove('hidden');
                    if (arrivalSound) {
                        // Tenta tocar o som
                        arrivalSound.play().catch(e => console.warn("A reprodução automática de áudio pode ter sido bloqueada.", e));
                    }
                    silenceBtn.classList.remove('hidden');
                    break;
                case 'in_progress':
                    chegueiImage.classList.add('hidden'); // Esconde a imagem se estava visível
                    message = `Viagem em andamento. Boa viagem!`;
                    getIcon('in-progress').innerHTML = `<img src="images/destino.png" alt="Viagem Iniciada" class="h-20 w-20 mx-auto animate-bounce">`;
                    getIcon('in-progress').classList.remove('hidden');
                    break;
                 case 'scheduled': // Adicionado status agendado
                    message = `Sua corrida está agendada.`;
                    getIcon('searching').classList.remove('hidden'); // Usa ícone de busca para agendado
                    break;
                default:
                    message = `Status: ${translateStatus(ride.status)}`;
                    // Pode adicionar um ícone padrão aqui se quiser
                    break;
            }

            statusMessageEl.innerHTML = message + scheduleInfo + driverInfo;

            // Lógica para mostrar/esconder botões
            if (ride.request_type === 'scheduled' && ['pending_approval', 'approved', 'scheduled', 'assigned', 'accepted'].includes(ride.status)) {
                editScheduleBtn.classList.remove('hidden');
            } else {
                editScheduleBtn.classList.add('hidden');
            }

            // Permite cancelar se estiver pendente, aprovado, solicitado, agendado, designado ou aceito
            if (['pending_approval', 'approved', 'requested', 'scheduled', 'assigned', 'accepted'].includes(ride.status)) {
                cancelRideBtn.classList.remove('hidden');
            } else {
                cancelRideBtn.classList.add('hidden');
            }
        }

        async function cancelRide() {
            if (state.currentUserRideId) {
                showModal('modal', 'Tem certeza que deseja cancelar esta solicitação?', async () => {
                    const { error } = await supabaseClient.from('rides').update({ status: 'canceled' }).eq('id', state.currentUserRideId);
                    if (error) {
                        showModal('modal', 'Não foi possível cancelar a corrida.');
                        console.error('Erro ao cancelar corrida:', error);
                    } else {
                        // Não mostra modal de sucesso, apenas atualiza o status que removerá a corrida ativa
                        await checkUserRideStatus();
                    }
                }, true);
            }
        }


        // --- Funções fetchAllData, setupRealtimeSubscriptions --- (sem alterações)
        async function fetchAllData() {
            const { data: users, error: usersError } = await supabaseClient.from('users').select('*');
            if (usersError) console.error('Error fetching users:', usersError); else state.users = users;

            const { data: rides, error: ridesError } = await supabaseClient.from('rides').select('*');
            if (ridesError) console.error('Error fetching rides:', ridesError); else state.rides = rides;
        }

        function setupRealtimeSubscriptions() {
            supabaseClient.channel('public:rides').on(
                'postgres_changes',
                { event: '*', schema: 'public', table: 'rides' },
                async (payload) => { // Marca a função como async
                    // Atualiza os dados locais primeiro para ter a informação mais recente
                    await fetchAllData();

                    // Verifica se a mudança é relevante para o usuário atual
                    const relevantRide = payload.new?.userId === state.currentUser?.id || payload.old?.userId === state.currentUser?.id;

                    if (state.currentUser && relevantRide) {
                       await checkUserRideStatus(); // Usa await para garantir que a verificação termine
                    }
                }
            ).subscribe((status, err) => {
                 if (status === 'SUBSCRIBED') { console.log('Conectado ao canal de corridas!'); }
                 if (err) { console.error('Erro na assinatura do canal de corridas:', err); }
            });
        }

        // --- FUNÇÃO DE INICIALIZAÇÃO PRINCIPAL --- (sem alterações lógicas, apenas garante ordem)
        async function initApp() {
            loadAppIcon();

            await fetchAllData(); // Carrega dados antes de decidir a tela

            // Inicializa autocomplete nos campos (será re-inicializado ao mostrar a tela do usuário se necessário)
            initAutocomplete(document.getElementById('origin'), (feature) => { state.selectedOrigin = feature; });
            updateDestinationFields(1); // Inicializa campos de destino

            const loggedInUserJSON = localStorage.getItem('loggedInUser');
            if (loggedInUserJSON) {
                try {
                    state.currentUser = JSON.parse(loggedInUserJSON);
                    if (state.currentUser && state.currentUser.id) {
                         document.getElementById('user-welcome-message').textContent = `Olá, ${state.currentUser.name}!`;
                         setupRealtimeSubscriptions(); // Configura subscriptions ANTES de mostrar a tela
                         await showScreen('user-screen'); // Mostra a tela e verifica status da corrida
                    } else {
                        throw new Error("Dados de usuário inválidos no localStorage");
                    }
                } catch (e) {
                     console.error("Erro ao processar usuário logado:", e);
                     logoutUser(); // Desloga se houver erro
                }
            } else {
                showScreen(localStorage.getItem('lastScreen') || 'initial-screen');
            }
        }

        // --- Função handleVideoEnd --- (sem alterações)
        function handleVideoEnd() {
            if (document.body.dataset.videoEnded) return;
            document.body.dataset.videoEnded = "true";

            const videoContainer = document.getElementById('video-container');
            const appContainer = document.getElementById('app-container');

            if (videoContainer) videoContainer.style.display = 'none';
            if (appContainer) appContainer.classList.remove('hidden');

            initApp(); // Chama initApp APÓS o vídeo terminar
        }

        const video = document.getElementById('intro-video');
        if (video) {
            video.addEventListener('ended', handleVideoEnd);
            video.addEventListener('error', handleVideoEnd);
            setTimeout(handleVideoEnd, 10000); // Timeout de segurança
        } else {
            // Se não houver vídeo, inicia imediatamente
            const appContainer = document.getElementById('app-container');
            if (appContainer) appContainer.classList.remove('hidden');
            initApp();
        }

        // ========================================================================
        // FUNÇÃO ATUALIZADA - initAutocomplete (Usa Geoapify)
        // ========================================================================
        function initAutocomplete(inputElement, onPlaceSelectCallback) {
            if (!inputElement || typeof Autocomplete === 'undefined') return;

            // Remove instância anterior para evitar duplicatas
            if (inputElement.geoapify_autocomplete_instance) {
                inputElement.geoapify_autocomplete_instance.destroy();
                inputElement.geoapify_autocomplete_instance = null;
            }

            const autocomplete = new Autocomplete(inputElement, {
                apiKey: GEOAPIFY_API_KEY,
                filter: { countrycode: ['br'] },
                lang: 'pt',
                placeholder: inputElement.placeholder,
                allowNonVerifiedHouseNumber: true,
                allowNonVerifiedStreet: true
            });

            autocomplete.on('select', (feature) => {
                if (feature && onPlaceSelectCallback) {
                    onPlaceSelectCallback(feature); // Chama o callback com os dados do local
                } else if (!feature && onPlaceSelectCallback) {
                    // Se o usuário apagar o campo ou não selecionar, limpa os dados
                    onPlaceSelectCallback(null);
                }
            });

            // Guarda a instância no elemento para poder destruir depois se necessário
            inputElement.geoapify_autocomplete_instance = autocomplete;
        }


        // ========================================================================
        // FUNÇÃO ATUALIZADA - updateDestinationFields (Inicializa Autocomplete)
        // ========================================================================
        function updateDestinationFields(passengerCount) {
            const container = document.getElementById('destinations-container');
            container.innerHTML = '';
            state.selectedDestinationsData = new Array(parseInt(passengerCount)).fill(null); // Reseta/Cria array para guardar dados

            for (let i = 1; i <= passengerCount; i++) {
                const inputContainer = document.createElement('div');
                inputContainer.className = 'mb-4 input-and-button-container autocomplete-container'; // Adiciona classe container

                const label = document.createElement('label');
                label.htmlFor = `destination-${i}`;
                label.className = 'block mb-2 text-sm font-medium';
                label.textContent = `Destino Passageiro ${i}`;
                if (i === 1) {
                    label.innerHTML += ' <span class="text-red-400">(Obrigatório)</span>';
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.id = `destination-${i}`;
                input.className = 'w-full p-3 rounded-lg bg-gray-800 border border-gray-600 focus:ring-2 focus:ring-yellow-300 focus:outline-none'; // Estilo normal
                input.placeholder = 'Digite o endereço completo';

                inputContainer.appendChild(label);
                inputContainer.appendChild(input);
                container.appendChild(inputContainer);

                // Inicializa o autocomplete para este campo de destino
                // Usa um índice (i-1) para salvar os dados no array state.selectedDestinationsData
                initAutocomplete(input, (feature) => {
                    state.selectedDestinationsData[i - 1] = feature;
                });
            }
        }


        // --- Funções translateStatus, loadAppIcon, renderUserRideHistory, showHistoryModal, openEditScheduleModal, confirmScheduleEdit, exportUserRidesToExcel ---
        // Nenhuma alteração necessária aqui.

        function translateStatus(status) {
            const translations = {
                'pending_approval': 'AGUARDANDO APROVAÇÃO', 'approved': 'APROVADA', 'rejected': 'REJEITADA', 'requested': 'SOLICITADO', 'assigned': 'DESIGNADO', 'accepted': 'ACEITO', 'arrived_pickup': 'NO LOCAL', 'in_progress': 'EM ANDAMENTO', 'scheduled': 'AGENDADO', 'completed': 'FINALIZADA', 'canceled': 'CANCELADA',
            };
            return translations[status] || status.toUpperCase();
        }

        function loadAppIcon() {
            const iconContainer = document.getElementById('app-icon-container');
            iconContainer.innerHTML = `<img src="${state.appIcon}" class="h-full w-full object-contain">`;
        }

        async function renderUserRideHistory() {
            await fetchAllData();
            const historyContainer = document.getElementById("user-ride-history-modal");
            if (!historyContainer || !state.currentUser) return;

            historyContainer.innerHTML = '';
            const userRides = state.rides.filter(r => r.userId === state.currentUser.id).sort((a, b) => new Date(b.requestTime) - new Date(a.requestTime));

            if (userRides.length === 0) {
                historyContainer.innerHTML = '<p class="text-center text-gray-400">Nenhum histórico de corrida.</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'w-full text-sm text-left';
            table.innerHTML = `
                <thead class="text-xs text-gray-300 uppercase bg-gray-900/30">
                    <tr>
                        <th scope="col" class="px-4 py-3">Data e Hora</th>
                        <th scope="col" class="px-4 py-3">Destino</th>
                        <th scope="col" class="px-4 py-3">Status</th>
                    </tr>
                </thead>`;
            const tbody = document.createElement('tbody');

            userRides.forEach(ride => {
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-700';
                const dateTimeString = new Date(ride.requestTime).toLocaleString('pt-BR');

                let historyDestination = ride.destination;
                try {
                    // Tenta interpretar o destino como JSON (array de strings)
                    const destinationsArray = JSON.parse(ride.destination);
                    if (Array.isArray(destinationsArray) && destinationsArray.length > 0) {
                        historyDestination = destinationsArray.join('; '); // Junta múltiplos destinos
                    }
                } catch (e) { /* Mantém o destino como string se não for JSON válido */ }

                row.innerHTML = `
                    <td class="px-4 py-3">${dateTimeString}</td>
                    <td class="px-4 py-3">${historyDestination}</td>
                    <td class="px-4 py-3">${translateStatus(ride.status)}</td>
                `;
                tbody.appendChild(row);
            });
            table.appendChild(tbody);
            historyContainer.appendChild(table);
        }


        function showHistoryModal() {
            renderUserRideHistory().then(() => {
                const modal = document.getElementById('history-modal');
                if (modal) {
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                }
            });
        }

        async function openEditScheduleModal(rideId) {
            const currentRideId = rideId || state.currentUserRideId;
            if (!currentRideId) {
                 showModal('modal', 'Não foi possível identificar a corrida para edição.');
                 return;
            }

            await fetchAllData();

            const rideToEdit = state.rides.find(r => r.id === currentRideId);
            if (!rideToEdit) {
                showModal('modal', 'Corrida não encontrada para edição.');
                return;
            }

            const modal = document.getElementById('schedule-modal');
            const dateInput = document.getElementById('schedule-date');
            const timeInput = document.getElementById('schedule-time');
            const confirmBtn = modal.querySelector('button.button-gradient');

            // Verifica se a data agendada existe e é válida
             let existingDate;
             try {
                if (rideToEdit.scheduled_datetime) {
                    existingDate = new Date(rideToEdit.scheduled_datetime);
                    if (isNaN(existingDate.getTime())) { // Checa se a data é inválida
                         throw new Error("Data inválida");
                    }
                } else {
                     throw new Error("Sem data agendada");
                }
             } catch (e) {
                 console.warn("Não foi possível carregar a data agendada existente, usando data/hora atual.", e);
                 existingDate = new Date(); // Usa data/hora atual como fallback
             }

            dateInput.value = existingDate.toISOString().split('T')[0];
            timeInput.value = existingDate.toTimeString().slice(0, 5);
            dateInput.min = new Date().toISOString().split('T')[0];

            confirmBtn.textContent = 'SALVAR ALTERAÇÕES';
            confirmBtn.onclick = () => confirmScheduleEdit(currentRideId);

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        async function confirmScheduleEdit(rideId) {
            const dateInput = document.getElementById('schedule-date');
            const timeInput = document.getElementById('schedule-time');

            if (!dateInput.value || !timeInput.value) {
                showModal('modal', 'Por favor, selecione uma data e hora válidas.');
                return;
            }

            const newScheduledDateTime = new Date(`${dateInput.value}T${timeInput.value}`);
            if (newScheduledDateTime < new Date()) {
                showModal('modal', 'A data e hora do agendamento não podem ser no passado.');
                return;
            }

            const { error } = await supabaseClient
                .from('rides')
                .update({ scheduled_datetime: newScheduledDateTime.toISOString() })
                .eq('id', rideId);

            if (error) {
                showModal('modal', 'Erro ao atualizar o agendamento. Tente novamente.');
                console.error('Erro ao editar agendamento:', error);
            } else {
                closeModal('schedule-modal');
                showModal('modal', 'Agendamento atualizado com sucesso!');
                checkUserRideStatus();
            }
        }

        function exportUserRidesToExcel() {
            if (!state.currentUser) return; // Adiciona verificação
            const userRides = state.rides.filter(r => r.userId === state.currentUser.id);
            if (userRides.length === 0) {
                showModal("modal", "Nenhum histórico de corrida para exportar.");
                return;
            }

            const dataToExport = userRides.map(ride => {
                let excelDestination = ride.destination;
                try {
                    const destinations = JSON.parse(ride.destination);
                    if (Array.isArray(destinations) && destinations.length > 0) {
                        excelDestination = destinations.filter(d => d).join('; ');
                    }
                } catch (e) { /* Mantém a string original */ }

                return {
                    'Data Solicitação': new Date(ride.requestTime).toLocaleString('pt-BR'),
                    'Destino(s)': excelDestination,
                    'Motorista': ride.driverName || 'N/A',
                    'Status': translateStatus(ride.status),
                    'Tipo': ride.request_type === 'immediate' ? 'Imediato' : 'Agendado',
                    'Data Agendada': ride.scheduled_datetime ? new Date(ride.scheduled_datetime).toLocaleString('pt-BR') : 'N/A'
                }
            });

            const worksheet = XLSX.utils.json_to_sheet(dataToExport);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Minhas Corridas");

            XLSX.writeFile(workbook, "meu_historico_corridas.xlsx");
        }


        // --- BOTÃO DE SOLICITAR --- (Função de clique movida para cá para garantir ordem)
        document.getElementById('request-ride-btn').onclick = function() {
            // A lógica aqui agora é apenas coletar os dados e ir para a tela de tipo
            const originAddress = document.getElementById('origin').value.trim();
            const passengerCount = document.getElementById('passenger-count').value;

            // Valida origem
            if (!state.selectedOrigin || state.selectedOrigin.properties.formatted !== originAddress) {
                showModal('modal', 'Endereço de ORIGEM inválido. Por favor, selecione um da lista de sugestões.');
                return;
            }

            // Valida pelo menos o primeiro destino
            let firstDestinationValid = false;
            const destInput1 = document.getElementById(`destination-1`);
            const destAddress1 = destInput1 ? destInput1.value.trim() : '';
            const selectedData1 = state.selectedDestinationsData[0];
            if (destAddress1 && selectedData1 && selectedData1.properties.formatted === destAddress1) {
                 firstDestinationValid = true;
            }

            if (!firstDestinationValid) {
                showModal('modal', 'O destino do primeiro passageiro é obrigatório e precisa ser selecionado da lista.');
                return;
            }

            // Valida destinos adicionais (se preenchidos)
             for (let i = 1; i < passengerCount; i++) {
                 const destInput = document.getElementById(`destination-${i + 1}`);
                 const destAddress = destInput ? destInput.value.trim() : '';
                 const selectedData = state.selectedDestinationsData[i];
                 if (destAddress && (!selectedData || selectedData.properties.formatted !== destAddress)) {
                      showModal('modal', `Endereço do DESTINO ${i+1} inválido. Por favor, selecione um da lista de sugestões ou deixe em branco.`);
                     return;
                 }
             }

            // Guarda a observação
            selectedObservation = document.getElementById('observation').value.trim();

            // Mostra a tela para escolher Imediato ou Agendado
            showScreen('request-type-screen');
        };

        // Adiciona listener para quantidade de passageiros para atualizar os campos de destino
        const passengerSelect = document.getElementById('passenger-count');
        if (passengerSelect) {
             passengerSelect.addEventListener('change', (e) => updateDestinationFields(e.target.value));
        }

    </script>
    </body>
</html>